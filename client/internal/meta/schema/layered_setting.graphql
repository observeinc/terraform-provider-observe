extend type Query {
    searchLayeredSettingRecords(query: LayeredSettingRecordsQueryInput): SearchLayeredSettingRecordsResult!
    possibleLayeredSettings: LayeredSettingDocs!
    layeredSettingRecord(id: ObjectId!): LayeredSettingRecord!
    layeredSettingValue(name:String!, target: LayeredSettingContextInput): TargetedLayeredSettingValue!
}

"""
A Layered Setting is like a feature flag that can be controlled by customers.
It allows control on a per-scope basis, where scope could be entire customer,
workspace, folder, app, dataset, monitor, or similar, with a broad-to-detailed
inheritance hierarchy.

A Layered Setting Record is a record setting the value of a Layered Setting at
a particular scope.  When the value of a Layered Setting is read from a
particular scope, we merge the Layered Setting Records at each scope that
contains the requested scope to determine the return value.
"""
type LayeredSettingRecord implements WorkspaceObject & AuditedObject & FolderObject @goModel(model: "observe/lsetting.LayeredSettingRecord") {
    settingAndTargetScope: SettingAndTargetScope!
    value: PrimitiveValue!

    id: ObjectId!
    """ This is the name of the settings record, not the name of the setting! """
    name: String!
    """ This is the description of the settings record, not the description of the setting! """
    description: String
    iconUrl: String
    workspaceId: ObjectId!
    """ reading managedBy for many objects is expensive -- don't do that in a wide search result """
    managedBy: WorkspaceObject @goField(forceResolver: true)
    managedById: ObjectId

    folderId: ObjectId!

    createdBy: UserId!
    createdByInfo: UserInfo! @goField(forceResolver: true)
    updatedBy: UserId!
    updatedByInfo: UserInfo! @goField(forceResolver: true)
    createdDate: Time!
    updatedDate: Time!
}

type SettingAndTargetScope @goModel(model: "observe/lsetting.SettingAndTargetScope") {
    setting: String!
    target: LayeredSettingRecordTarget!
}

"""
When configuring a particular target, a single object ID should be non-null
in the LayeredSettingRecordTarget. If you want to affect "everything in this folder,
and also this particular dataset," then create two LayeredSettingRecords.
"""
type LayeredSettingRecordTarget @goModel(model: "observe/lsetting.SettingTarget") {
    customerId: CustomerId
    workspaceId: ObjectId
    folderId: ObjectId
    appId: ObjectId
    monitorId: ObjectId
    worksheetId: ObjectId
    dashboardId: ObjectId
    datastreamId: ObjectId
    datasetId: ObjectId
    rbacGroupId: ORN
    userId: UserId
}

type LayeredSettingDescription @goModel(model: "observe/lsetting.LayeredSettingDescription") {
    setting: String!
    type: ValueType!
    defaultValue: PrimitiveValue!
    possibleTargetScopes: [SettingTargetScope!]!
    description: String!
    writableBy: [String!]!
}

type TargetedLayeredSettingValue @goModel(model: "observe/lsetting.TargetedLayeredSettingValue") {
    description: LayeredSettingDescription!
    settingRecords: [LayeredSettingRecord!]!
    value: PrimitiveValue!
}

type LayeredSettingDocs @goModel(model: "observe/lsetting.LayeredSettingDocs") {
    descriptions: [LayeredSettingDescription!]!
}

type SearchLayeredSettingRecordsResult @goModel(model: "observe/lsetting.SearchLayeredSettingRecordsResult") {
    settingRecords: [LayeredSettingRecord!]!
}

input LayeredSettingRecordsQueryInput @goModel(model: "observe/lsetting.LayeredSettingRecordsQueryInput") {
    setting: String
    target: LayeredSettingTargetQueryInput
    """
    This is for "the record lives in this workspace," NOT for "the record affects this workspace."
    """
    workspaceId: ObjectId
    """
    This is for "the record lives in this folder," NOT for "the record affects this folder."
    """
    folderId: ObjectId
    """
    This is for "the record is managed by this object," NOT for "the record affects this object."
    """
    managedById: ObjectId
}

input LayeredSettingTargetQueryInput @goModel(model: "observe/lsetting.SettingTargetQueryInput") {
    customerId: CustomerId
    workspaceId: ObjectId
    folderId: ObjectId
    appId: ObjectId
    monitorId: ObjectId
    worksheetId: ObjectId
    dashboardId: ObjectId
    datastreamId: ObjectId
    datasetId: ObjectId
    rbacGroupId: ORN
    userId: UserId
}

input LayeredSettingContextInput @goModel(model: "observe/lsetting.SettingContextInput") {
    customerId: CustomerId
    workspaceId: ObjectId
    folderId: ObjectId
    appId: ObjectId
    monitorId: ObjectId
    worksheetId: ObjectId
    dashboardId: ObjectId
    datastreamId: ObjectId
    datasetId: ObjectId
    userId: UserId
}

input LayeredSettingRecordTargetInput @goModel(model: "observe/lsetting.SettingTargetInput") {
    customerId: CustomerId
    workspaceId: ObjectId
    folderId: ObjectId
    appId: ObjectId
    worksheetId: ObjectId
    dashboardId: ObjectId
    datastreamId: ObjectId
    monitorId: ObjectId
    datasetId: ObjectId
    rbacGroupId: ORN
    userId: UserId
}

enum SettingTargetScope @goModel(model: "observe/lsetting.SettingTargetScope") {
    Cluster
    Customer
    Workspace
    Folder
    App
    Worksheet
    Dashboard
    Datastream
    Monitor
    Dataset
    RbacGroup
    User
}

extend type Mutation {
    createLayeredSettingRecord(settingRecord:LayeredSettingRecordInput!): LayeredSettingRecord!
    updateLayeredSettingRecord(settingRecord:LayeredSettingRecordInput!): LayeredSettingRecord!
    clearLayeredSettingRecords(settingRecords:LayeredSettingRecordsQueryInput!): DeletedLayeredSettingRecordsResult!
    deleteLayeredSettingRecord(id:ObjectId!): DeletedLayeredSettingRecordsResult!
}

input LayeredSettingRecordInput @goModel(model: "observe/lsetting.LayeredSettingRecordInput") {
    settingAndTargetScope: SettingAndTargetScopeInput!
    value: PrimitiveValueInput!

    id: ObjectId
    """
    This is the name of the settings record, not the name of the setting!

    If you give the layered setting record the empty name, it will get an auto-generated
    name based on the setting and target. This is mainly convenient when creating these
    within code itself, but can also be used by API users who don't want to manage a
    separate name.
    """
    name: String!
    """ This is the description of the settings record, not the description of the setting! """
    description: String
    iconUrl: String
    workspaceId: ObjectId!
    managedById: ObjectId

    folderId: ObjectId
}

input SettingAndTargetScopeInput @goModel(model: "observe/lsetting.SettingAndTargetScopeInput") {
    setting: String!
    target: LayeredSettingRecordTargetInput!
}

type DeletedLayeredSettingRecordsResult @goModel(model: "observe/lsetting.DeletedLayeredSettingRecordsResult") {
    settingRecords: [DeletedLayeredSettingRecord!]
    result: ResultStatus!
}

type DeletedLayeredSettingRecord @goModel(model: "observe/lsetting.DeletedLayeredSettingRecord") {
    settingAndTargetScope: SettingAndTargetScope!
    id: ObjectId!
}

