extend type Query {
    dashboardSearch(terms: DWSearchInput!, maxCount: Int64): DashboardSearchResultWrapper!
    worksheetSearch(terms: DWSearchInput!, maxCount: Int64): WorksheetSearchResultWrapper!

    """
    Parameter searchMode defaults to InclusiveMode, which means "any matches,
    counts" sorted by better-scoring.  If you pass in ExclusiveMode, then you
    get "must match each thing" behavior, which may end up returning no datasets
    at all quite easily.
    """
    datasetSearch(projects: [ObjectId!], labelMatches: [String!], columnMatches: [String!], keyMatchTypes: [String!], foreignKeyTargetMatches: [String!], correlationTagMatches: [String!], reachableFromDataset:ObjectId, implementsInterfaces: [String!], sourceMatches: [String!], searchMode: SearchMode, excludeMonitorV1Datasets: Boolean, excludeMonitorV2Datasets: Boolean): [DatasetMatch!]!
}

extend type Subscription {
    datasetWatch(workspaceId: ObjectId!, watchOptions: DatasetWatchOptions): [DatasetWatchUpdate!]!
}

type DatasetMatchData @goModel(model: "observe/meta/metatypes.DatasetMatchData") {
    score: Float!
    matchedProject: [ObjectId!]
    matchedLabel: [String!]
    matchedColumn: [String!]
    matchedKey: [String!]
    matchedForeignKey: [String!]
    matchedCorrelationTag: [String!]
    matchedInterface: [String!]
}

type DatasetMatch @goModel(model: "observe/meta/metatypes.DatasetMatch") {
    dataset: Dataset!
    matchData: DatasetMatchData!
}

"""
Same search input used for Dashboards and Worksheets, hence, DWSearchInput.
"""
input DWSearchInput @goModel(model: "observe/meta/metakind.SearchSpec") {
    name:  [String!]
    workspaceId:  [ObjectId!]
    workspaceName:  [String!]
    folderId:  [ObjectId!]
    folderName:  [String!]
    user: [UserId!]
    """
    If set, only objects with one of the specified visibilities are returned.
    Note: Unlisted items created by other users are always excluded from results.
    """
    visibility: [ObjectVisibility!]
    parameter: [ParameterSearchInput!]
    input: [InputSearchInput!]
}

input ParameterSearchInput @goModel(model: "observe/meta/metakind.ParameterSearchSpec") {
    """
    name will do case insensitive substring match against the name AND id of the parameter
    """
    name: [String!]
    kind: [ValueType!]
    resource: [ObjectId!]
    tag: [String!]
    input: [InputSearchInput!]
}

input InputSearchInput @goModel(model: "observe/meta/metakind.InputSearchSpec") {
    """
    name is a dataset path, which gets resolved to ID before matching. Not resolved means no match.
    """
    name: [String!]
    id: [ObjectId!]
}

type DashboardSearchResult @goModel(model: "observe/meta/metakind.DashboardSearchResult") {
    dashboard:  Dashboard!
    score:  Int64!
    inWorkspace:  Boolean!
    inFolder:  Boolean!
    numParameters:  Int64!
    numInputs:  Int64!
}

type DashboardSearchResultWrapper @goModel(model: "observe/meta/metakind.DashboardSearchResultWrapper") {
    dashboards: [DashboardSearchResult!]!
    warnings: [String!]!
}

type WorksheetSearchResult @goModel(model: "observe/meta/metakind.WorksheetSearchResult") {
    worksheet:  Worksheet!
    score:  Int64!
    inWorkspace:  Boolean!
    numParameters:  Int64!
    numInputs:  Int64!
}

type WorksheetSearchResultWrapper @goModel(model: "observe/meta/metakind.WorksheetSearchResultWrapper") {
    worksheets: [WorksheetSearchResult!]!
    warnings: [String!]!
}

input DatasetWatchOptions @goModel(model: "observe/meta/metatypes.DatasetWatchOptions") {
    """
    if specified, only sources that prefix-match one of these filters will be included
    """
    filterSources: [String!]
    """
    if specified, only specific datasets will be watched
    """
    filterDatasets: [ObjectId!]
}

type DatasetWatchUpdate @goModel(model: "observe/meta/metatypes.DatasetWatchUpdate") {
    updated: [Dataset!]
    deleted: [ObjectId!]
    """
    When only keys change, those datasets are put in `related` not `updated`
    """
    related: [Dataset!]
    error: String
}

enum SearchMode @goModel(model: "observe/meta/metakind.SearchMode") {
    InclusiveMode
    ExclusiveMode
}
