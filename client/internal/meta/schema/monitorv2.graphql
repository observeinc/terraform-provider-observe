extend type Query {
    monitorV2(id: ObjectId!): MonitorV2!
    searchMonitorV2(workspaceId: ObjectId, folderId: ObjectId, nameExact: String, nameSubstring: String): MonitorV2SearchResult!
    monitorV2Action(id: ObjectId!): MonitorV2Action!
    searchMonitorV2Action(workspaceId: ObjectId, folderId: ObjectId, nameExact: String, nameSubstring: String): MonitorV2ActionSearchResult!
    monitorV2MuteRule(id: ObjectId!): MonitorV2MuteRule!
    searchMonitorV2MuteRule(workspaceId: ObjectId, folderId: ObjectId, nameExact: String, nameSubstring: String): MonitorV2MuteRuleSearchResult!
}

extend type Mutation {
    createMonitorV2(workspaceId: ObjectId!, input: MonitorV2Input!): MonitorV2!
    updateMonitorV2(id: ObjectId!, input: MonitorV2Input!): MonitorV2!
    deleteMonitorV2(id: ObjectId!): ResultStatus!
    createMonitorV2Action(workspaceId: ObjectId!, input: MonitorV2ActionInput!): MonitorV2Action!
    updateMonitorV2Action(id: ObjectId!, input: MonitorV2ActionInput!): MonitorV2Action!
    deleteMonitorV2Action(id: ObjectId!): ResultStatus!
    createMonitorV2MuteRule(workspaceId: ObjectId!, input: MonitorV2MuteRuleInput!): MonitorV2MuteRule!
    updateMonitorV2MuteRule(id: ObjectId!, input: MonitorV2MuteRuleInput!): MonitorV2MuteRule!
    deleteMonitorV2MuteRule(id: ObjectId!): ResultStatus!
}

"""
MonitorV2ActionType defines the type of monitor returned when querying all
actions for a monitor.
"""
enum MonitorV2ActionType @goModel(model: "observe/meta/metatypes.MonitorV2ActionType") {
  Email
  PagerDuty
  Slack
  Webhook
}

"""
MonitorV2AlarmLevel presents the severity level a user can choose for their monitor.
The NoData severity is a special placeholder for the no data rule.
"""
enum MonitorV2AlarmLevel @goModel(model: "observe/meta/metatypes.MonitorV2AlarmLevel") {
  Critical
  Error
  Informational
  NoData
  None
  Warning
}

"""
MonitorV2AlertType simply describes what type of alert template dictionary you'd like to generate
as part of the monitorV2TemplateDictionary method. This MonitorV2AlertType is what shows up as the
type of alert for the user -- New, Reminder, or Ended.
"""
enum MonitorV2AlertType @goModel(model: "observe/meta/metatypes.MonitorV2AlertType") {
  Ended
  New
  Reminder
}

enum MonitorV2BooleanOperator @goModel(model: "observe/meta/metatypes.MonitorV2BooleanOperator") {
  And
  Or
}

"""
These are functions meant to express comparison against standard deviation bounds.
"""
enum MonitorV2BoundComparisonFunction @goModel(model: "observe/meta/metatypes.MonitorV2BoundComparisonFunction") {
  Above
  AboveOrBelow
  Below
}

"""
MonitorV2CapturedType describes the type of column that's captured in the dataset which the monitor observes over.
There are 2 types:
  1. GroupBy:         If a monitor is grouped by this particular column, this will be one of the types that's tagged.
  2. Aggregation:     If this column is the aggregation column used for count or threshold strategy type, this will
                      be the type that's tagged.
Note: LinkSourceField is deprecated and not used in the backend anymore as it can be inferred from the monitor v2 meta fields.
"""
enum MonitorV2CapturedValueType @goModel(model: "observe/meta/metatypes.MonitorV2CapturedValueType") {
  Aggregation
  GroupBy
  LinkSourceField
}

enum MonitorV2ComparisonFunction @goModel(model: "observe/meta/metatypes.MonitorV2ComparisonFunction") {
  Contains
  Equal
  Greater
  GreaterOrEqual
  IsNotNull
  IsNull
  Less
  LessOrEqual
  NotContains
  NotEqual
  NotStartsWith
  StartsWith
}

"""
MonitorV2HttpType describes the two HTTP request methods that users can choose to alert to
their desired webhook destinations: POST and PUT.
"""
enum MonitorV2HttpType @goModel(model: "observe/meta/metatypes.MonitorV2HttpType") {
  Post
  Put
}

enum MonitorV2MuteScheduleType @goModel(model: "observe/meta/metatypes.MonitorV2MuteScheduleType") {
  OneTime
  Recurring
}

"""
MonitorV2RollupStatus is a convenience indicator of how to perceive the state of the monitor.
This value is derived entirely using existing data in other fields, but
encapsultes those inspections into a single priority-based status.
Some status indicators are not exclusive with others so, for example, a monitor that is "Triggering"
may also be "Degraded" because of underlying warnings.
This priority-sorted rollup is just to let the user prioritize and sort things in the UI in an order
we define as most sensible. This ordering can be changed as needed.
In descending order of priority, the values are:
 - Failed: The last error occured after the last runtime and is less than a week old.
 - Warnings: The last warning occured after the last runtime and is less than a week old.
 - Disabled: The monitor is not running because it is disabled by the user or by the system due to chronic failures.
 - Running: The default state. If no other status is indicated, the monitor is running.
"""
enum MonitorV2RollupStatus @goModel(model: "observe/meta/metatypes.MonitorV2RollupStatus") {
  Disabled
  Failed
  Running
  Warnings
}

"""
MonitorV2RuleKind describes the strategy used to inspect the input query.
 - Count is used when what you care to inspect is the number of rows/instances 
   in the query result.
 - Threshold is when you want to inspect a numerical value within the query 
   results, not the presence of the rows themselves.
 - Promote is when you want to curate your own alerts using Observe's query
   language without the monitor doing any additional data modeling behind the
   scene.
 - Anomaly is when you want alert based on any irregularity noticed in the new 
   set of data using the expected trend from modeling the data in the past.
"""
enum MonitorV2RuleKind @goModel(model: "observe/meta/metatypes.MonitorV2RuleKind") {
  Anomaly
  Count
  Promote
  Threshold
}

"""
MonitorV2ValueAggregation describes the numerical/value aggregations for the Value
monitor type. These types map to your typical query aggregators except count, which is its own
monitor type since it acts on rows, not on values.
 - AllOf: This is like "all values > 80" (which is like saying min(value) > 80)
 - AnyOf: This is like "any value > 80" (which is like saying max(value) > 80)
 - SumOf: This sums all values over the lookback and makes that the value to compare
 - AvgOf: This averages all values over the lookback and makes that the value to compare
 - Min: This takes the minimum value over the lookback and makes that the value to compare
 - Max: This takes the maximum value over the lookback and makes that the value to compare
"""
enum MonitorV2ValueAggregation @goModel(model: "observe/meta/metatypes.MonitorV2ValueAggregation") {
  AllOf
  AnyOf
  AvgOf
  Max
  Min
  SumOf
}

type MonitorV2 implements WorkspaceObject & AuditedObject & FolderObject @goModel(model: "observe/meta/metatypes.MonitorV2") {
    """
    Indicates if the monitor is enabled or disabled. Use setMonitorV2Enabled to flip this flag
    one way or the other by itself.
    note: This was previously not supported as an input flag, but it was added as an input
    flag to support TF and REST.
    """
    disabled: Boolean
    """
    A longer description of the monitor.
    This can include details like how to resolve the issue, links to runbooks, etc.
    """
    comment: String @deprecated(reason:"Use the description field over the comment field")
    meta: MonitorV2Meta @goField(forceResolver: true)
    rollupStatus: MonitorV2RollupStatus! @goField(forceResolver: true)
    definition: MonitorV2Definition!
    """
    Describes the type of each of the rules in the definition (they must all be the same type).
    """
    ruleKind: MonitorV2RuleKind!
    """
    ActiveAlarms enumerates the active alarm instances for this monitor.
    """
    activeAlarms: [MonitorV2Alarm!]! @goField(forceResolver: true)
    """
    ActiveAlarmCount returns the number of active alarms. A non-zero count here is
    the same as saying "this monitor is triggering". This value, in conjunction with
    lastAlarmTime can inform which monitors in a list view may be most interesting to
    bring to attention.
    """
    activeAlarmCount: Int64! @goField(forceResolver: true)
    """
    List of actions and conditions for dispatching. Each entry will
    contain the action definition regardless of whether the definition is
    shared or provided inline.
    """
    actionRules: [MonitorV2ActionRule!]! @goField(forceResolver: true)
    """
    MonitorVersion matches what will be emitted with datastream events to bind the monitor
    definition to those events. This value is what you would use with monitorV2DefinitionByVersion.
    It just happens to be derived from the UpdatedDate but that detail should be considered opaque
    to API users.
    """
    monitorVersion: Int64!
    """
    Mutes is a list of mute rules currently linked to this monitor.
    """
    mutes: [MonitorV2MuteRule!]! @goField(forceResolver: true)
    """
    InvestigationInfo describes structured information the monitor creator
    wishes to advertise for investigators of alerts. This includes things like
    runbook references.
    """
    investigationInfo: MonitorV2InvestigationInfo @deprecated(reason:"This is a POC field and not for production use.")
    """
    GovernorStatus represents the cost governor status of this monitor.
    When a cost limit is configured (at monitor or customer level), this field
    indicates whether the monitor is running normally, in a grace period, or
    disabled due to exceeding cost limits.
    """
    governorStatus: MonitorV2GovernorStatus @goField(forceResolver: true)
    id: ObjectId!
    workspaceId: ObjectId!
    name: String!
    iconUrl: String
    description: String
    managedById: ObjectId
    managedBy: WorkspaceObject @goField(forceResolver: true)

    folderId: ObjectId!

    createdBy: UserId!
    createdDate: Time!
    createdByInfo: UserInfo! @goField(forceResolver: true)
    updatedBy: UserId!
    updatedDate: Time!
    updatedByInfo: UserInfo! @goField(forceResolver: true)
}

input MonitorV2Input @goModel(model: "observe/meta/metatypes.MonitorV2Input") {
    sharingRules: [MonitorSharingRuleInput!]
    disabled: Boolean
    comment: String
    definition: MonitorV2DefinitionInput!
    ruleKind: MonitorV2RuleKind!
    investigationInfo: MonitorV2InvestigationInfoInput
    name: String!
    iconUrl: String
    description: String
    managedById: ObjectId

    folderId: ObjectId
}

type MonitorV2SearchResult @goModel(model: "observe/meta/metatypes.MonitorV2SearchResult") {
    results: [MonitorV2!]!
}

type MonitorV2ForAlarm @goModel(model: "observe/meta/metatypes.MonitorV2ForAlarm") {
    id: ObjectId!
    name: String!
    description: String!
}

input MonitorV2ForAlarmInput @goModel(model: "observe/meta/metatypes.MonitorV2ForAlarmInput") {
    id: ObjectId!
    name: String!
    description: String!
}


type MonitorV2Meta @goModel(model: "observe/meta/metatypes.MonitorV2Meta") {
    """
    The last run statistics. This type is also what gets emitted into the datastream for
    historical purposes.
    """
    lastRunStats: MonitorV2Stats
    isInactive: Boolean! @deprecated(reason:"No longer used")
    """
    The timestamp of the last error message emited to the monitoring datastream.
    This value can be filtered or used to inform whether the user should be directed to
    investigate the monitor's log messages for problems to remediate. These messages
    indicate fatal errors that prevent the monitor from working.
    """
    lastErrorTime: Time
    """
    The timestamp of the last warning message emited to the monitoring datastream.
    This value can also be filtered to inform a user if deeper investigation should
    be done.
    Warning messages indicate a degraded monitor, which is one that can emit results but
    cannot perform all functions or perform them optimally for some reason.
    """
    lastWarningTime: Time
    """
    The timestamp of the last alarm this monitor generated.
    This value can be filtered or used to inform if the user should look into the historical
    log of detection events.
    note: This value may be quite recent but for a non-active alarm in the case the event detected
    was a one-shot event.
    """
    lastAlarmTime: Time
    """
    The output dataset identifier of this monitor. This can be used to query information about the
    dataset and all upstream dependencies using dataset APIs for transform-based monitors.
    """
    outputDatasetID: ObjectId
    """
    Describes the alert's schema installed by the transform-based monitor.
    """
    alertSchema: MonitorV2AlertSchema
    """
    The expected next time this monitor will run if it's a schedule-based monitor.
    """
    nextScheduledTime: Time
    """
    The expected next time this monitor will run if it's a schedule-based monitor.
    """
    lastScheduleBookmark: Time
    """
    Describes the type of scheduling scheme used for this monitor. The value could be one of the following:
    - Interval
    - Transform
    - Scheduled
    """
    effectiveScheduling: MonitorV2Scheduling!
}

input MonitorV2MetaInput @goModel(model: "observe/meta/metatypes.MonitorV2MetaInput") {
    lastRunStats: MonitorV2StatsInput
    isInactive: Boolean!
    lastErrorTime: Time
    lastWarningTime: Time
    lastAlarmTime: Time
    outputDatasetID: ObjectId
    alertSchema: MonitorV2AlertSchemaInput
    outputDatasetStrategyVersion: String
    nextScheduledTime: Time
    lastScheduleBookmark: Time
}


type MonitorV2InvestigationInfo @goModel(model: "observe/meta/metatypes.MonitorV2InvestigationInfo") {
    """
    This is free-form text used in investigation POC work and likely will be
    removed in preference to reference links. DO NOT USE THIS FIELD FOR PRODUCTION.
    """
    runbookContent: String!
}

input MonitorV2InvestigationInfoInput @goModel(model: "observe/meta/metatypes.MonitorV2InvestigationInfoInput") {
    runbookContent: String!
}


type MonitorV2AlertSchema @goModel(model: "observe/meta/metatypes.MonitorV2AlertSchema") {
    """
    All the columns that are inside the captured values of the alert.
    """
    columns: [MonitorV2Column!]
}

input MonitorV2AlertSchemaInput @goModel(model: "observe/meta/metatypes.MonitorV2AlertSchemaInput") {
    columns: [MonitorV2ColumnInput!]
}


type MonitorV2Definition @goModel(model: "observe/meta/metatypes.MonitorV2Definition") {
    """
    InputQuery is the MultiStageQuery that defines the input feed of data for this monitor. It will include the
    original dataset(s) and other transform information that the user selected to create "Create Monitor".
    """
    inputQuery: MultiStageQuery!
    """
    RuleTemplate is the additional attributes for a monitor rule kind. Some monitor kinds like count and promote don't
    have any common attributes, but for kinds like anomaly there are attributes shared amongst all rules such as the
    detection algorithm, out of bound condition, and more.
    """
    ruleTemplate: MonitorV2RuleTemplate
    """
    NoDataRules allows a user to be alerted on missing data for the specified lookback window. When provided,
    the severity is fixed to the NoData severity. As of today, the max number of no data rules that can be created
    is 1 for the threshold monitor kind.
    """
    noDataRules: [MonitorV2NoDataRule!]
    """
    Rules are one or more instances of a MonitorV2Rule, which all must be of the same MonitorRuleKind
    as specified in `ruleKind`.
    Rules should be constructed logically such that a state transition from null->Warning implies a
    transition from null->Informational as well.
    """
    rules: [MonitorV2Rule!]!
    """
    LookbackTime optionally describes a duration that must be satisifed by this monitor. It applies to all rules,
    but is only applicable to rule kinds that utilize it.
    """
    lookbackTime: Duration
    """
    DataStabilizationDelay expresses the minimum time that should elapse before data is considered "good enough"
    to evaluate. Choosing a delay really depends on the expectations of latency of data and whether data is expected
    to arrive later than other data and thus would change previously evaluated results. Another way to think of this
    value is defining where the "Ragged Right Edge" starts relative to the clock.
    """
    dataStabilizationDelay: Duration
    """
    MaxAlertsPerHour sets the rate allowed before a monitor is considered possibly bad
    and automatically disabled by the system. This has a default value of 100 if null/unset.
    A value of 0 means "no limit".
    """
    maxAlertsPerHour: Int64
    """
    Groupings describes the groups that logically separate events/rows/etc from each other.
    When the input monitor dataset is of type resource and the monitor strategy is of type promote, this field should
    either be left empty to be mutated with the primary keys of the resource dataset or it should only contain the 
    primary keys of the dataset.
    """
    groupings: [MonitorV2Column!]
    """
    Scheduling controls how often the monitor is evaluated. The default behavior when you do
    not specify this field is a real-time transform monitor with a default freshness goal that
    you cannot control.
    """
    scheduling: MonitorV2Scheduling
    """
    The custom variables allow the Monitor definition to convey desired variables to the
    notification templates. The values in this object should be strings that can contain
    simple mustache templates that will be rendered prior to the action rendering
    and will be made available to the action as {{monitor.variables.key}} where
    'key' is the key in this object.
    note: These are distinctly different than the action fragments, which are treated as
    mustache partials.
    """
    customVariables: JsonObject
}

input MonitorV2DefinitionInput @goModel(model: "observe/meta/metatypes.MonitorV2DefinitionInput") {
    inputQuery: MultiStageQueryInput!
    ruleTemplate: MonitorV2RuleTemplateInput
    noDataRules: [MonitorV2NoDataRuleInput!]
    rules: [MonitorV2RuleInput!]!
    lookbackTime: Duration
    dataStabilizationDelay: Duration
    maxAlertsPerHour: Int64
    groupings: [MonitorV2ColumnInput!]
    scheduling: MonitorV2SchedulingInput
    customVariables: JsonObject
}


type MonitorV2RuleTemplate @goModel(model: "observe/meta/metatypes.MonitorV2RuleTemplate") {
    anomaly: MonitorV2AnomalyRuleTemplate
}

input MonitorV2RuleTemplateInput @goModel(model: "observe/meta/metatypes.MonitorV2RuleTemplateInput") {
    anomaly: MonitorV2AnomalyRuleTemplateInput
}


type MonitorV2AnomalyRuleTemplate @goModel(model: "observe/meta/metatypes.MonitorV2AnomalyRuleTemplate") {
    """
    ComputationWindow describes the length of the window used to compute the average and the deviation.
    When not provided, the computation window will be dynamically chosen based on the lookbackTime provided.
    """
    computationWindow: Duration
    """
    ValueColumnName indicates which of the columns in the input query to apply the basic algorithm and create
    bounds over.
    """
    valueColumnName: String!
    """
    CompareFn allows the user to select one of above, below, or above or below standard deviations to be
    the bounds the data point has to be out.
    """
    compareFn: MonitorV2BoundComparisonFunction!
    """
    NumStandardDeviations defines how many standard deviations the data point has to be out of bounds to
    be marked as a red point. The user gets to choose a standard deviation between 1 to 5.
    """
    numStandardDeviations: Int64!
    """
    BasicAlgorithm makes the monitor use the basic algorithm to evaluate data and fire alerts. For the 
    computation window of data, it will calculate the average and standard deviations and then determine
    whether the new point is out of bound. As of now, it will be of type JsonObject in anticipation to
    introduce MonitorV2BasicAnomalyAlgorithm in the future only if the need for special fields appear.
    To use the basic algorithm, set this value to an empty object.
    """
    basicAlgorithm: JsonObject
}

input MonitorV2AnomalyRuleTemplateInput @goModel(model: "observe/meta/metatypes.MonitorV2AnomalyRuleTemplateInput") {
    computationWindow: Duration
    valueColumnName: String!
    compareFn: MonitorV2BoundComparisonFunction!
    numStandardDeviations: Int64!
    basicAlgorithm: JsonObject
}


type MonitorV2IntervalSchedule @goModel(model: "observe/meta/metatypes.MonitorV2IntervalSchedule") {
    """
    Interval is how often the monitor should attempt to run. This interval describes when the
    monitor enters the queue, but is not a guarantee of execution. Monitors are best-effort
    and also may be subject to QoS or rate limiting in the future.
    """
    interval: Duration!
    """
    Randomize is a maximum +/- to apply to the interval to avoid things like harmonics and
    work stacking up in parallel. If interval is "10m" and randomize is "30s", then a random
    interval between 9m30s and 10m30s will be selected each run.
    """
    randomize: Duration!
}

input MonitorV2IntervalScheduleInput @goModel(model: "observe/meta/metatypes.MonitorV2IntervalScheduleInput") {
    interval: Duration!
    randomize: Duration!
}


type MonitorV2TransformSchedule @goModel(model: "observe/meta/metatypes.MonitorV2TransformSchedule") {
    freshnessGoal: Duration!
}

input MonitorV2TransformScheduleInput @goModel(model: "observe/meta/metatypes.MonitorV2TransformScheduleInput") {
    freshnessGoal: Duration!
}


type MonitorV2CronSchedule @goModel(model: "observe/meta/metatypes.MonitorV2CronSchedule") {
    """
    If specified, the raw cron is a crontab configuration to use to drive the scheduling.
    """
    rawCron: String
    """
    A timezone is required to ensure that interpretation of scheduling on the wall-clock
    is done relative to the desired timezone.
    """
    timezone: String!
}

input MonitorV2CronScheduleInput @goModel(model: "observe/meta/metatypes.MonitorV2CronScheduleInput") {
    rawCron: String
    timezone: String!
}


type MonitorV2Scheduling @goModel(model: "observe/meta/metatypes.MonitorV2Scheduling") {
    """
    Interval is being deprecated, as it has supportability problems.
    Interval was used to support a transform-like evaluation model which supported continous
    monitoring use cases with unaccelerable OPAL.
    """
    interval: MonitorV2IntervalSchedule @deprecated(reason:"Use transform or scheduled monitor instead.")
    """
    Transform should be specified to explicitly set the style to transform or to configure
    the transform behavior.
    """
    transform: MonitorV2TransformSchedule
    """
    Cron should be specified to get wall-clock scheduled evaluation.
    """
    scheduled: MonitorV2CronSchedule
}

input MonitorV2SchedulingInput @goModel(model: "observe/meta/metatypes.MonitorV2SchedulingInput") {
    interval: MonitorV2IntervalScheduleInput
    transform: MonitorV2TransformScheduleInput
    scheduled: MonitorV2CronScheduleInput
}


type MonitorV2CapturedValue @goModel(model: "observe/meta/metatypes.MonitorV2CapturedValue") {
    """
    Types capture the type of this column for the alarm. If the captured value has a groupby type,
    it will be a column that was part of the groupings in the monitor. If the captured value has an aggregation
    type, it will be the column that's used to capture the aggregated value for the count or threshold monitor.
    """
    types: [MonitorV2CapturedValueType!]!
    """
    Includes all the metadata surrounding the column for either the link or the normal colum path.
    """
    column: MonitorV2Column!
    """
    Value is the value of the captured column in the dataset.
    """
    value: String
}

input MonitorV2CapturedValueInput @goModel(model: "observe/meta/metatypes.MonitorV2CapturedValueInput") {
    types: [MonitorV2CapturedValueType!]!
    column: MonitorV2ColumnInput!
    value: String
}


type MonitorV2Column @goModel(model: "observe/meta/metatypes.MonitorV2Column") {
    """
    Type of the column such as string, int64, and more.
    """
    columnType: FieldType
    """
    Link Column is for link typed column which the user wants to group by.
    """
    linkColumn: MonitorV2LinkColumn
    """
    Column path is any non-link typed column along with an optional path which the user wants to group by.
    """
    columnPath: MonitorV2ColumnPath
}

input MonitorV2ColumnInput @goModel(model: "observe/meta/metatypes.MonitorV2ColumnInput") {
    linkColumn: MonitorV2LinkColumnInput
    columnPath: MonitorV2ColumnPathInput
}


type MonitorV2LinkColumn @goModel(model: "observe/meta/metatypes.MonitorV2LinkColumn") {
    name: String!
    """
    Any context surrounding the link column as part of the MonitorV2Alarm will be described here. This column
    will include the source dataset's and the target dataset's columns linked together to create the current
    link column.
    """
    meta: MonitorV2LinkColumnMeta
}

input MonitorV2LinkColumnInput @goModel(model: "observe/meta/metatypes.MonitorV2LinkColumnInput") {
    name: String!
    meta: MonitorV2LinkColumnMetaInput
}


type MonitorV2LinkColumnMeta @goModel(model: "observe/meta/metatypes.MonitorV2LinkColumnMeta") {
    """
    List of source fields used to link against the primary keys of the target dataset.
    Frontend only needs to provide the input for this field when it wants a preview of the template fields.
    """
    srcFields: [MonitorV2ColumnPath!]
    """
    List of destination fields (a.k.a. primary keys) of the target dataset being linked against.
    Frontend only needs to provide the input for this field when it wants a preview of the template fields.
    """
    dstFields: [String!]
    """
    The target dataset is the resource dataset id which the link came from. If the link was created from a stage in
    the shape of a resource from the worksheet, this field will be empty as there's no resource dataset to point to.
    Frontend only needs to provide the input for this field when it wants a preview of the template fields.
    """
    targetDataset: Int64
}

input MonitorV2LinkColumnMetaInput @goModel(model: "observe/meta/metatypes.MonitorV2LinkColumnMetaInput") {
    srcFields: [MonitorV2ColumnPathInput!]
    dstFields: [String!]
    targetDataset: Int64
}


type MonitorV2ColumnPath @goModel(model: "observe/meta/metatypes.MonitorV2ColumnPath") {
    name: String!
    path: String
}

input MonitorV2ColumnPathInput @goModel(model: "observe/meta/metatypes.MonitorV2ColumnPathInput") {
    name: String!
    path: String
}


type MonitorV2Rule @goModel(model: "observe/meta/metatypes.MonitorV2Rule") {
    """
    Level is the severity level to assign to a rule's conditions being matched.
    """
    level: MonitorV2AlarmLevel!
    count: MonitorV2CountRule
    """
    The aggregation and value column provided must be identical across all rules.
    """
    threshold: MonitorV2ThresholdRule
    promote: MonitorV2PromoteRule
    anomaly: MonitorV2AnomalyRule
}

input MonitorV2RuleInput @goModel(model: "observe/meta/metatypes.MonitorV2RuleInput") {
    level: MonitorV2AlarmLevel!
    count: MonitorV2CountRuleInput
    threshold: MonitorV2ThresholdRuleInput
    promote: MonitorV2PromoteRuleInput
    anomaly: MonitorV2AnomalyRuleInput
}


type MonitorV2AnomalyRule @goModel(model: "observe/meta/metatypes.MonitorV2AnomalyRule") {
    """
    ComparePercentage is the percentage of points that needs to be out of bound within the evaluation
    window for the monitor to trigger the anomaly rule. It will always do a greater than or equal to
    evaluation of this following comparison. It accepts a range between 0 to 100.
    """
    comparePercentage: Int64
    """
    CompareGroups is a list of comparisons made against the columns which the monitor is grouped by.
    This gives the option to add extra dimension to the existing rule by specifying which column of
    the group the user looks forward to being alerted by. For example, this allows for rule expression
    like (Count > 80 and Group = "Good Group") which would trigger a critical alert.
    """
    compareGroups: [MonitorV2ColumnComparison!]
}

input MonitorV2AnomalyRuleInput @goModel(model: "observe/meta/metatypes.MonitorV2AnomalyRuleInput") {
    comparePercentage: Int64
    compareGroups: [MonitorV2ColumnComparisonInput!]
}


type MonitorV2CountRule @goModel(model: "observe/meta/metatypes.MonitorV2CountRule") {
    """
    CompareValues is a list of comparisons that provide an implicit AND where all comparisons must match.
    This gives the option to specify
    one value for a threshold behavior (trigger if > 80) but also allows for ranges of validity. If you want
    to trigger inside a range, give two compares here (like > 80 and < 90). If you want to trigger
    outside a valid range, use two rules with a single compare to get the implied OR
    (one rule for < 80 and one rule for > 90).
    """
    compareValues: [MonitorV2Comparison!]!
    """
    CompareGroups is a list of comparisons made against the columns which the monitor is grouped by.
    This gives the option to add extra dimension to the existing rule by specifying which column of
    the group the user looks forward to being alerted by. For example, this allows for rule expression
    like (Count > 80 and Group = "Good Group") which would trigger a critical alert.
    """
    compareGroups: [MonitorV2ColumnComparison!]
}

input MonitorV2CountRuleInput @goModel(model: "observe/meta/metatypes.MonitorV2CountRuleInput") {
    compareValues: [MonitorV2ComparisonInput!]!
    compareGroups: [MonitorV2ColumnComparisonInput!]
}


type MonitorV2ThresholdRule @goModel(model: "observe/meta/metatypes.MonitorV2ThresholdRule") {
    """
    CompareValues is a list of comparisons that provide an implicit AND where all comparisons must match.
    This gives the option to specify one value for a threshold behavior (trigger if > 80) but also allows
    for ranges of validity. If you want to trigger inside a range, give two compares here (like > 80 and < 90).
    If you want to trigger outside a valid range, use two rules with a single compare to get the implied OR
    (one rule for < 80 and one rule for > 90).
    CompareValues can only be left empty when the NoDataOption is provided as there's no values to compare against
    when we want to alert on the data itself missing.
    """
    compareValues: [MonitorV2Comparison!]
    """
    ValueColumnName indicates which of the columns in the input query has the value to apply to the aggregation.
    """
    valueColumnName: String!
    aggregation: MonitorV2ValueAggregation!
    """
    CompareGroups is a list of comparisons made against the columns which the monitor is grouped by.
    This gives the option to add extra dimension to the existing rule by specifying which column of
    the group the user looks forward to being alerted by. For example, this allows for rule expression
    like (Threshold > 80 and Group = "Good Group") which would trigger a critical alert.
    """
    compareGroups: [MonitorV2ColumnComparison!]
}

input MonitorV2ThresholdRuleInput @goModel(model: "observe/meta/metatypes.MonitorV2ThresholdRuleInput") {
    compareValues: [MonitorV2ComparisonInput!]
    valueColumnName: String!
    aggregation: MonitorV2ValueAggregation!
    compareGroups: [MonitorV2ColumnComparisonInput!]
}


type MonitorV2NoDataRule @goModel(model: "observe/meta/metatypes.MonitorV2NoDataRule") {
    """
    Allows for the user to specify how long they'd like the missing data alert to persist for before
    it resolves by itself. If not provided, the default expiration time will be set to 24 hours. The
    expiration must be identical across all rules.
    """
    expiration: Duration
    """
    Adds the ability for threshold monitor to have a no data rule. When this input is provided here,
    you must provide the aggregation and valueColumnName, while the compareGroups is optional. The
    compareValues should be left empty. The aggregation and value column provided must be identical
    across all rules.
    """
    threshold: MonitorV2ThresholdRule
    """
    Adds the ability for anomaly monitor to have a no data rule. When this input is provided here,
    nothing needs to be provided to its fields as they're made optional.
    """
    anomaly: MonitorV2AnomalyRule
}

input MonitorV2NoDataRuleInput @goModel(model: "observe/meta/metatypes.MonitorV2NoDataRuleInput") {
    expiration: Duration
    threshold: MonitorV2ThresholdRuleInput
    anomaly: MonitorV2AnomalyRuleInput
}


type MonitorV2PromoteRule @goModel(model: "observe/meta/metatypes.MonitorV2PromoteRule") {
    """
    If this field has been specified, it means there are values in the columns that we want to assign severity by.
    When multiple column comparisons are specified within one promote rule, it will act as an AND condition. When defined
    through separate promote rules, it will be treated as an OR condition.
    If the field is left as an empty array by the frontend, all the rows of the dataset will be considered as an alert.
    For example, if the field is left empty and the level of the MonitorV2Rule is set at critical, all the rows of the dataset
    will be treated as a critical alert.
    """
    compareColumns: [MonitorV2ColumnComparison!]
}

input MonitorV2PromoteRuleInput @goModel(model: "observe/meta/metatypes.MonitorV2PromoteRuleInput") {
    compareColumns: [MonitorV2ColumnComparisonInput!]
}


type MonitorV2ColumnComparison @goModel(model: "observe/meta/metatypes.MonitorV2ColumnComparison") {
    """
    CompareValues is a list of comparisons that provide an implicit AND where all comparisons must match.
    This gives the option to specify one value for a threshold behavior (trigger if > 80) but also allows
    for ranges of validity. If you want to trigger inside a range, give two compares here (like > 80 and < 90).
    If you want to trigger outside a valid range, use two rules with a single compare to get the implied OR
    (one rule for < 80 and one rule for > 90).
    """
    compareValues: [MonitorV2Comparison!]!
    """
    The column user wants to compare against using the values inside compareValues.
    """
    column: MonitorV2Column!
    """
    Operator specifies the logical operator (AND/OR) used to combine multiple comparison clauses within this column comparison.
    When multiple comparison values are provided in compareValues, they are combined using the OR operator by default. However,
    if any of the comparison functions (i.e. compareFn) within the compareValues are Not.* functions, the operator will be set to AND automatically.
    """
    operator: MonitorV2BooleanOperator
}

input MonitorV2ColumnComparisonInput @goModel(model: "observe/meta/metatypes.MonitorV2ColumnComparisonInput") {
    compareValues: [MonitorV2ComparisonInput!]!
    column: MonitorV2ColumnInput!
    operator: MonitorV2BooleanOperator
}


type MonitorV2AlarmActionStats @goModel(model: "observe/meta/metatypes.MonitorV2AlarmActionStats") {
    """
    MonitorID is the monitor object id
    """
    monitorID: ObjectId!
    """
    AlarmID is the alarm/alert identifier
    """
    alarmID: String!
    """
    NumNotifsDiscarded tells the total events discarded that might otherwise have
    generated a notification. This could be because there is no matching rule or
    there is a matching mute or similar. It does not count events ignored
    that are not subscribed to (like end notifications when end notifications are
    not enabled).
    """
    numNotifsDiscarded: Int64!
    """
    NumNotifsMuted counts the number of events that might have generated a notification
    but didn't because they matched a mute rule.
    """
    numNotifsMuted: Int64!
    """
    LastMuteTime is updated every time NumNotifsMuted is incremeneted.
    """
    lastMuteTime: Time
    """
    NumNotifsSent counts the number of notifications that were dispatched
    to their destination.
    """
    numNotifsSent: Int64!
    """
    LastSendtime is updated every time NumNotifsSent is incremeneted
    """
    lastSendTime: Time
    """
    NumErrors is incremented whenever there is a failure generating or evaluating
    a candidate notification. This might be due to template rendering errors
    or objects having been deleted.
    """
    numErrors: Int64!
    """
    LastErrorTime is updated every time NumErrors is incremented.
    """
    lastErrorTime: Time
    """
    This unique identifier is assigned by the detection pipeline to the
    detection event (when it originates in the detection pipeline) and can be
    connected back to that evaluation, the stats of that evaluation, and the
    events in the same evaluation.
    note: In rare cases, events are not generated from detections so the
    evaluationID will not correlate to stats, etc.
    """
    evaluationID: String!
}

input MonitorV2AlarmActionStatsInput @goModel(model: "observe/meta/metatypes.MonitorV2AlarmActionStatsInput") {
    monitorID: ObjectId!
    alarmID: String!
    numNotifsDiscarded: Int64!
    numNotifsMuted: Int64!
    lastMuteTime: Time
    numNotifsSent: Int64!
    lastSendTime: Time
    numErrors: Int64!
    lastErrorTime: Time
    evaluationID: String!
}


type MonitorV2Stats @goModel(model: "observe/meta/metatypes.MonitorV2Stats") {
    monitorID: ObjectId!
    """
    OutputDatasetId is the monitor's output dataset id, which is the dataset that feeds monitor evaluation
    """
    outputDatasetID: ObjectId
    """
    DataFreshnessTime is the effective upstream data freshness as seen by the monitor at the time
    of evaluation. For transform monitor's, this is the monitoring dataset freshness time. Otherwise, it
    is computed from the upstream datasets from the input query as the oldest value of all of those.
    This can be used to infer latency of data into monitor evaluation (when compared to StartTime).
    """
    dataFreshnessTime: Time!
    """
    StabilityBookmarkTime is the value that monitoring used at the time of evaluation to
    decide what predicted results are valid, and how long to wait on results that are not yet valid.
    This is based
    on the perceived freshness time of the data and the stability delay. This value can be informative
    to answering why expected monitoring results may not yet be seen.
    """
    stabilityBookmarkTime: Time!
    """
    WindowStart is the minimum window start time seen in the dataset updates for this run.
    In most cases, this will be the start of the single update event.
    """
    windowStart: Time!
    """
    WindowEnd is the maximum window end time seen in the dataset updates for this run.
    """
    windowEnd: Time!
    """
    EnqueueTime is the time when the work item for this run was created and enqueued.
    This will be the time we saw the update from the transformer, or the time we replayed the
    updates table.
    """
    enqueueTime: Time!
    """
    StartTime is the time at which the work was actually started.
    StartTime - EnqueueTime describes how long the work sat in the work queue waiting to run.
    """
    startTime: Time!
    """
    EndTime is the time at which the work completed.
    EndTime - StartTime is how long result query and evaluation took. This time will pretty much be entirely
    the dataset query in most cases.
    """
    endTime: Time!
    """
    NumDatasetRows is the number of dataset rows that were queried and iterated to generate results.
    """
    numDatasetRows: Int64!
    """
    NumReadyAlarmStates is the number of MonitorAlarmState's generated by this evaluation
    that are considered "ready" because
    they satisify the StabilityBookmarkTime. These may or may not generate state change events.
    """
    numReadyAlarmStates: Int64! @deprecated(reason:"No longer used")
    """
    NumFutureAlarmStates is the number of MonitorAlarmState's generated by this evaluation
    that are considered predictions
    because they do not satisfy the StabilityBookmarkTime. These results may get used to generate
    events at some evaluation point after the bookmark time.
    """
    numFutureAlarmStates: Int64! @deprecated(reason:"No longer used")
    """
    NumPackedAlarmStates is the number of MonitorAlarmState's generated by this evaluation
    that are already packed. Since evaluation only works on data that is considered
    "ready" by the bookmark, the number of dataset rows mostly conveys the unpacked
    result count.
    """
    numPackedAlarmStates: Int64!
    """
    NumEvaluatedGroupings is the distinct number of groupings that generated results (ready or future).
    This is a count of logically different entities are generating results.
    """
    numEvaluatedGroupings: Int64!
    """
    NumEventsGenerated conveys how many of the alarm states were converted into state
    change events in this evaluation for emission into the datastream and actions pipeline.
    """
    numEventsGenerated: Int64!
    """
    A unique identifier assigned to the evaluation that produced these stats.
    This value can be connected to down stream activities, like actions, to
    know what evaluation and statistics (like freshness time, etc) were that
    lead to the actions.
    """
    evaluationID: String!
}

input MonitorV2StatsInput @goModel(model: "observe/meta/metatypes.MonitorV2StatsInput") {
    monitorID: ObjectId!
    outputDatasetID: ObjectId
    dataFreshnessTime: Time!
    stabilityBookmarkTime: Time!
    windowStart: Time!
    windowEnd: Time!
    enqueueTime: Time!
    startTime: Time!
    endTime: Time!
    numDatasetRows: Int64!
    numReadyAlarmStates: Int64!
    numFutureAlarmStates: Int64!
    numPackedAlarmStates: Int64!
    numEvaluatedGroupings: Int64!
    numEventsGenerated: Int64!
    evaluationID: String!
}


type MonitorV2Alarm @goModel(model: "observe/meta/metatypes.MonitorV2Alarm") {
    id: String!
    """
    Start is the earliest timestamp for which the monitor has generated detection events.
    It is not the authoritative start time of the monitor's criteria, rather represents
    the current conclusion about when the criteria began matching.
    """
    start: Time!
    """
    End is the latest timestamp for which the monitor is projecting the criteria are
    met. If the active flag is false, this value can still be extended due to late-arriving data
    but it currently represents the monitor's current conclusion about when the criteria were
    no longer satisfied. If the active flag is true, then this is just the latest time for
    which the criteria are met.
    """
    end: Time
    """
    DetectedStart is the timestamp that represents the time when the alarm first became active. This
    means that this is equivalent to the time when the alarm was first created.
    """
    detectedStart: Time!
    """
    DetectedEnd is the timestamp that represents the time when the alarm last changed from active to an
    inactive state.
    """
    detectedEnd: Time
    """
    Captured values describe the value captured from the monitor output dataset. It can contain
    the groupBy columns, linkPrimaryKey coluns, aggregation columns, or the regular columns.
    """
    capturedValues: [MonitorV2CapturedValue!]!
    """
    IsActive indicates if the monitor is tracking this Alarm as not having yet satisified the
    crtieria to conclude the alarm is done. This can be for recent alarms but also can be
    for old alarms that have been extended due to late arriving data and have not been ended again.
    note: For now, this should always be true as the only feature supported is listing
    active alarms. Historical analysis should be done via the Monitoring datastream.
    note: The retention of these alarms is restricted to 28 days.
    """
    isActive: Boolean!
    """
    Level is the severity the user configured in the monitor to be alerted on.
    """
    level: MonitorV2AlarmLevel!
    """
    Grouping hash shows which group this alarm originates from based on the group by values.
    """
    groupingHash: Int64!
    """
    Version of the monitor at the time this alarm was created.
    """
    monitorVersion: Int64!
    """
    The monitor that generated this alarm.
    """
    monitor: MonitorV2ForAlarm @goField(forceResolver: true)
    """
    IsInvalid will be set when an alarm has previously been triggered but new data
    has caused the entire alarm to be considered a false positive. The alarm remains for
    historical purposes, including the start and end times, but the alarm itself is no
    longer valid.
    """
    isInvalid: Boolean!
    stats: MonitorV2AlarmActionStats @goField(forceResolver: true)
}

input MonitorV2AlarmInput @goModel(model: "observe/meta/metatypes.MonitorV2AlarmInput") {
    id: String!
    start: Time!
    end: Time
    detectedStart: Time!
    detectedEnd: Time
    capturedValues: [MonitorV2CapturedValueInput!]!
    isActive: Boolean!
    level: MonitorV2AlarmLevel!
}


type MonitorV2Preview @goModel(model: "observe/meta/metatypes.MonitorV2Preview") {
    alarms: [MonitorV2Alarm!]!
    """
    Displays the time until which the alarms are stable. Any alarm with an end time that
    crosses the bookmark time would mean that the end time may change from later arriving
    data. This is an internal backend heuristic to do the work of "anything after this
    time is potentially unstable and need to re-validate".
    """
    stabilityBookmarkTime: Time!
    """
    Retrieve the preview of the alert schema for the frontend. This way the frontend can utilize
    it for creating mutes or value-based routings before saving the monitor.
    """
    alertSchema: MonitorV2AlertSchema!
}




type MonitorV2Comparison @goModel(model: "observe/meta/metatypes.MonitorV2Comparison") {
    compareFn: MonitorV2ComparisonFunction!
    """
    The right-side value for comparisons that use it (like x > 10, this is 10).
    """
    compareValue: PrimitiveValue!
}

input MonitorV2ComparisonInput @goModel(model: "observe/meta/metatypes.MonitorV2ComparisonInput") {
    compareFn: MonitorV2ComparisonFunction!
    compareValue: PrimitiveValueInput!
}


type MonitorV2ActionRule @goModel(model: "observe/meta/metatypes.MonitorV2ActionRule") {
    """
    Takes in a private or public action id created from an earlier createAction API call.
    """
    actionID: ObjectId!
    """
    Dispatch this action when the alarm matches any of the provided levels
    AND'd with any of the optional conditions.
    """
    levels: [MonitorV2AlarmLevel!]
    """
    Conditions are additional comparisons to apply (AND'd with levels) to decide if an alert applies.
    """
    conditions: MonitorV2ComparisonExpression
    """
    Send notifications when the condition ends.
    note: At this time, this only happens on the AlarmEnded event.
    """
    sendEndNotifications: Boolean
    """
    Send a reminder notification for as long as the condition is active
    on this interval.
    """
    sendRemindersInterval: Duration
    """
    Included to be shown as part of the MonitorV2 output.
    """
    definition: MonitorV2ActionDefinition!
}

input MonitorV2ActionRuleInput @goModel(model: "observe/meta/metatypes.MonitorV2ActionRuleInput") {
    actionID: ObjectId!
    levels: [MonitorV2AlarmLevel!]
    conditions: MonitorV2ComparisonExpressionInput
    sendEndNotifications: Boolean
    sendRemindersInterval: Duration
}


type MonitorV2ActionDefinition @goModel(model: "observe/meta/metatypes.MonitorV2ActionDefinition") {
    """
    The inline field determines whether the object is inlined within another object or not. If not inlined, it can be shared with other objects.
    """
    inline: Boolean
    type: MonitorV2ActionType!
    email: MonitorV2EmailAction
    webhook: MonitorV2WebhookAction
}

input MonitorV2ActionDefinitionInput @goModel(model: "observe/meta/metatypes.MonitorV2ActionDefinitionInput") {
    inline: Boolean
    type: MonitorV2ActionType!
    email: MonitorV2EmailActionInput
    webhook: MonitorV2WebhookActionInput
}


type MonitorV2Action implements WorkspaceObject & AuditedObject & FolderObject @goModel(model: "observe/meta/metatypes.MonitorV2Action") {
    """
    The inline field determines whether the object is inlined within another object or not. If not inlined, it can be shared with other objects.
    """
    inline: Boolean
    type: MonitorV2ActionType!
    email: MonitorV2EmailAction
    webhook: MonitorV2WebhookAction
    id: ObjectId!
    workspaceId: ObjectId!
    name: String!
    iconUrl: String
    description: String
    managedById: ObjectId
    managedBy: WorkspaceObject @goField(forceResolver: true)

    folderId: ObjectId!

    createdBy: UserId!
    createdDate: Time!
    createdByInfo: UserInfo! @goField(forceResolver: true)
    updatedBy: UserId!
    updatedDate: Time!
    updatedByInfo: UserInfo! @goField(forceResolver: true)
}

input MonitorV2ActionInput @goModel(model: "observe/meta/metatypes.MonitorV2ActionInput") {
    inline: Boolean
    type: MonitorV2ActionType!
    email: MonitorV2EmailActionInput
    webhook: MonitorV2WebhookActionInput
    name: String!
    iconUrl: String
    description: String
    managedById: ObjectId

    folderId: ObjectId
}

type MonitorV2ActionSearchResult @goModel(model: "observe/meta/metatypes.MonitorV2ActionSearchResult") {
    results: [MonitorV2Action!]!
}

type MonitorV2EmailAction @goModel(model: "observe/meta/metatypes.MonitorV2EmailAction") {
    """
    A list of Observe users to email.
    """
    users: [UserId!]
    """
    A list of email addresses to email.
    """
    addresses: [String!]
    """
    The email subject template.
    """
    subject: String!
    """
    The email body template.
    """
    body: String
    """
    Fragments allow additional partial templates to be made available to the
    main action template using the {{>partial}} syntax.
    """
    fragments: JsonObject
}

input MonitorV2EmailActionInput @goModel(model: "observe/meta/metatypes.MonitorV2EmailActionInput") {
    users: [UserId!]
    addresses: [String!]
    subject: String!
    body: String
    fragments: JsonObject
}


type MonitorV2WebhookAction @goModel(model: "observe/meta/metatypes.MonitorV2WebhookAction") {
    """
    A webhook URL template to a destination that can be rendered.
    """
    url: String!
    """
    HTTP POST or PUT request into the webhook URL.
    """
    method: MonitorV2HttpType!
    """
    The webhook headers -- a header and a value template.
    """
    headers: [MonitorV2WebhookHeader!]
    """
    The webhook body template.
    """
    body: String!
    """
    Fragments allow additional partial templates to be made available to the
    main action template using the {{>partial}} syntax.
    """
    fragments: JsonObject
}

input MonitorV2WebhookActionInput @goModel(model: "observe/meta/metatypes.MonitorV2WebhookActionInput") {
    url: String!
    method: MonitorV2HttpType!
    headers: [MonitorV2WebhookHeaderInput!]
    body: String!
    fragments: JsonObject
}


type MonitorV2WebhookHeader @goModel(model: "observe/meta/metatypes.MonitorV2WebhookHeader") {
    """
    A webhook header.
    """
    header: String!
    """
    A value template that can be rendered.
    """
    value: String!
}

input MonitorV2WebhookHeaderInput @goModel(model: "observe/meta/metatypes.MonitorV2WebhookHeaderInput") {
    header: String!
    value: String!
}


type MonitorV2MuteRule implements WorkspaceObject & AuditedObject & FolderObject @goModel(model: "observe/meta/metatypes.MonitorV2MuteRule") {
    schedule: MonitorV2MuteRuleSchedule!
    """
    Criteria is optional evaluation to apply to decide if the mute applies to an individual
    notification. If criteria are not given the mute is applied to all notifications
    for the monitor.
    note: A global mute (null monitor assignment) with no criteria is not allowed.
    """
    criteria: MonitorV2ComparisonExpression
    """
    ValidFrom is the effective start time of the mute rule, calculated dynamically based on the schedule type.
    For ONE-TIME mute schedules:
      - ValidFrom is set to the schedule's startTime
    For RECURRING mute schedules:
      - A "cron schedule window" is a time period that starts at a cron trigger time and lasts for the specified duration
      - Example: If cron schedule triggers at 2:00 PM and duration is 1 hour, the window is [2:00 PM, 3:00 PM]
      - ValidFrom is set to:
        * If NOW is within a cron schedule window  the start of that window (cron trigger time)
        * If NOW is outside any window  the start of the NEXT window (next cron trigger time)
      - This means validFrom always points to when the current or next mute period begins
    """
    validFrom: Time!
    """
    ValidTo is the effective end time of the mute rule, calculated dynamically based on the schedule type.
    When null, the mute never expires.
    For ONE-TIME mute schedules:
      - ValidTo is set to the schedule's endTime (can be null for indefinite mutes)
    For RECURRING mute schedules:
      - A "cron schedule window" is a time period that starts at a cron trigger time and lasts for the specified duration
      - Example: If cron schedule triggers at 2:00 PM and duration is 1 hour, the window is [2:00 PM, 3:00 PM]
      - ValidTo is set to:
        * If NOW is within a cron schedule window  the end of that window (cron trigger time + duration)
        * If NOW is outside any window  the end of the NEXT window (next cron trigger time + duration)
      - This means validTo always points to when the current or next mute period ends
    """
    validTo: Time
    """
    MonitorID is an optional identifer you assign to bind this mute rule to a single monitor.
    Leaving this null makes the rule global (evaluates against all notifications of all monitors).
    """
    monitorID: ObjectId
    """
    Monitor is the monitor resolved by MonitorID.
    """
    monitor: MonitorV2 @goField(forceResolver: true)
    """
    IsGlobal is just a convenience flag driven by a null check on monitorID.
    """
    isGlobal: Boolean!
    """
    IsConditional is a convenience flag driven by checking if the rule contains
    any matching criteria. Having no matching criteria makes the rule an unconditional
    mute (suppresses all notifications). It is not permitted to have an unconditional
    mute be global.
    """
    isConditional: Boolean!
    id: ObjectId!
    workspaceId: ObjectId!
    name: String!
    iconUrl: String
    description: String
    managedById: ObjectId
    managedBy: WorkspaceObject @goField(forceResolver: true)

    folderId: ObjectId!

    createdBy: UserId!
    createdDate: Time!
    createdByInfo: UserInfo! @goField(forceResolver: true)
    updatedBy: UserId!
    updatedDate: Time!
    updatedByInfo: UserInfo! @goField(forceResolver: true)
}

input MonitorV2MuteRuleInput @goModel(model: "observe/meta/metatypes.MonitorV2MuteRuleInput") {
    schedule: MonitorV2MuteRuleScheduleInput!
    criteria: MonitorV2ComparisonExpressionInput
    monitorID: ObjectId
    name: String!
    iconUrl: String
    description: String
    managedById: ObjectId

    folderId: ObjectId
}

type MonitorV2MuteRuleSearchResult @goModel(model: "observe/meta/metatypes.MonitorV2MuteRuleSearchResult") {
    results: [MonitorV2MuteRule!]!
}

type MonitorV2MuteRuleSchedule @goModel(model: "observe/meta/metatypes.MonitorV2MuteRuleSchedule") {
    type: MonitorV2MuteScheduleType!
    oneTime: MonitorV2OneTimeMuteSchedule
    recurring: MonitorV2MuteCronSchedule
}

input MonitorV2MuteRuleScheduleInput @goModel(model: "observe/meta/metatypes.MonitorV2MuteRuleScheduleInput") {
    type: MonitorV2MuteScheduleType!
    oneTime: MonitorV2OneTimeMuteScheduleInput
    recurring: MonitorV2MuteCronScheduleInput
}


type MonitorV2OneTimeMuteSchedule @goModel(model: "observe/meta/metatypes.MonitorV2OneTimeMuteSchedule") {
    startTime: Time!
    endTime: Time
}

input MonitorV2OneTimeMuteScheduleInput @goModel(model: "observe/meta/metatypes.MonitorV2OneTimeMuteScheduleInput") {
    startTime: Time!
    endTime: Time
}


type MonitorV2MuteCronSchedule @goModel(model: "observe/meta/metatypes.MonitorV2MuteCronSchedule") {
    cronSchedule: MonitorV2CronSchedule!
    duration: Duration!
}

input MonitorV2MuteCronScheduleInput @goModel(model: "observe/meta/metatypes.MonitorV2MuteCronScheduleInput") {
    cronSchedule: MonitorV2CronScheduleInput!
    duration: Duration!
}


type MonitorV2MuteLink @goModel(model: "observe/meta/metatypes.MonitorV2MuteLink") {
    monitorID: ObjectId!
    ruleID: ObjectId!
}

input MonitorV2MuteLinkInput @goModel(model: "observe/meta/metatypes.MonitorV2MuteLinkInput") {
    monitorID: ObjectId!
    ruleID: ObjectId!
}


type MonitorV2ComparisonExpression @goModel(model: "observe/meta/metatypes.MonitorV2ComparisonExpression") {
    compareTerms: [MonitorV2ComparisonTerm!]
    subExpressions: [MonitorV2ComparisonExpression!]
    operator: MonitorV2BooleanOperator!
}

input MonitorV2ComparisonExpressionInput @goModel(model: "observe/meta/metatypes.MonitorV2ComparisonExpressionInput") {
    compareTerms: [MonitorV2ComparisonTermInput!]
    subExpressions: [MonitorV2ComparisonExpressionInput!]
    operator: MonitorV2BooleanOperator!
}


type MonitorV2ComparisonTerm @goModel(model: "observe/meta/metatypes.MonitorV2ComparisonTerm") {
    """
    Comparison describes the binary operator and the right-side value to compare.
    """
    comparison: MonitorV2Comparison!
    """
    Column indicates the comparison left-side value comes from the column indicated here.
    """
    column: MonitorV2Column!
}

input MonitorV2ComparisonTermInput @goModel(model: "observe/meta/metatypes.MonitorV2ComparisonTermInput") {
    comparison: MonitorV2ComparisonInput!
    column: MonitorV2ColumnInput!
}


type MonitorV2SetRulesResult @goModel(model: "observe/meta/metatypes.MonitorV2SetRulesResult") {
    links: [MonitorV2MuteLink!]!
}

input MonitorV2SetRulesResultInput @goModel(model: "observe/meta/metatypes.MonitorV2SetRulesResultInput") {
    links: [MonitorV2MuteLinkInput!]!
}


