extend type Subscription {
    """
    Same endpoint but streams results as they come.

    Does not time out, unless the websocket connection is closed or snowflake
    times out the underlying queries.
    """
    datasetProgressive(query: [StageInput!]!, params: QueryParams!, parameterValues:[ParameterBindingInput!], metadata: QueryMetadata): [TaskResult]!

    """
    Similar endpoint as datasetProgressive, but runs this query in Live streaming mode. All stages are currently grouped by
    their default input dataset (recursively in case it is another stage) and when new data arrives in that dataset then
    the stages' queries are re-executed.

    Different to datasetProgressive:
    * StageInput.Progressive is forced to false
    * StageInput.BestEffortBinding is forced to false
    * params is of type LiveQueryParams, which
    + Has a query window size (duration) instead of a frame (start, end). The actual query window frame for the queries is determined
    by (start = now - duration, end = now), where "now" is the time when new data arrived in the dataset.
    + Has an optional parameter runImmediately, which when set will make all queries run immediately once before waiting for data updates.

    In Live Mode:
    * Observe queries are run repeatedly, once after new data was ingested for the datasets which participate in each stage.
    * After this subscription was started, the handler starts checking for new data ingested.
    * As soon as for a stage's main input new data was ingested, that stage is re-executed and that new result returned.
    * In case the client wants to immediately run the query once without waiting for new data, it must set the optional parameter `runImmediately`.
    * Each stage is executed individually, as with the datasetProgressive subscription.
    * This subscription will stop in the following cases:
    * The client explicitly stops it.
    * After 5 minutes as a safeguard against high credit burn.
    Afterwards, Live Mode stays enabled another 1 minute as a grace period to allow the client to continue Live Mode through a new subscription.
    * The websocket connection is lost / times out.
    Afterwards, Live Mode stays enabled another 3 minutes to accomodate for e.g. lossy connections and allow the user to reconnect and start a fresh subscription.
    Otherwise, it continuesly sends new complete results as soon as new data is available in the main input.
    * The value of StageInput.progressive will be ignored.
    * The query window is moved, not extended.
    * Until we have real incremental execution we always send "complete" (non-incremental) results to the client.
    """
    datasetLiveQuery(query: [StageInput!]!, params: LiveQueryParams!, parameterValues:[ParameterBindingInput!], metadata: QueryMetadata): [LiveQueryResult]!
}

extend type Query {
    """
    Given a cursorId from a previous query, you can arrange to get a URL that you can
    GET to get the data pointed-at by that cursor. The URL will only have a limited
    lifetime, and will have headers that suggest a browser treats it as a
    download. The download will have the suggested filename you request, or a
    generated filename if not provided. The data will have the file format
    you request, or default to Csv.
    """
    exportCursor(cursorId: String!, filename: String, exportFormat: ExportFileFormat): ExportCursorResult!
    """
    Given a query (such as you'd pass to datasetProgressive() or checkQueries()),
    run the query, and export the results to a cursor, then prepare the export URL for
    that cursor with the same parameters as exportCursor(), and return that URL.
    """
    exportQuery(query: MultiStageQueryInput!, params: QueryParams!, presentation: StagePresentationInput, rowCount: Int64, filename: String, exportFormat: ExportFileFormat, metadata: QueryMetadata): ExportCursorResult!

    """
    Pull more results from a cursor. rollupFilter provides more granular
    filter for rolled-up results. Must be nil for any unrolled-up result.
    Default to the "all" mode for backward compatibility.
    """
    cursor(cursorId: String!, offset: Int64!, numRows: Int64!, rollupFilter: RollupFilterInput): PaginatedResults

    """
    Given some datasets and pipeline expressions, run the query and extract the
    query results.  Errors in input specification come back as GQL/HTTP errors,
    but syntax errors in the parsed query come back in the parsedPipeline result
    set for each query.

    Times out after 2 minutes.
    """
    datasetQueryOutput(query: [StageInput!]!, params: QueryParams!, parameterValues: [ParameterBindingInput!], metadata: QueryMetadata): [TaskResult!]!

    stats(startTime: Time!, endTime: Time!, wkCols: [StatsWKCol!], dsQueries: [StatsDatasetQueryInput!]!): StatsQueryResult

    """
    Eventually this should be replaced by the usage dashboard, which has more
    complete stats than this limited API.
    """
    queryRateLimitingStats(workspaceId: ObjectId!): QueryRateLimitingStats

    """
    This is equivalent to queryRateLimitingStats{dailyAvgCreditUsagePast7Days}.
    This is a separate query so that it can be called very frequently and as a
    result, will do the minimal amount of work needed to get the result
    """
    queryWeeklyCreditUtilization: QueryWeeklyCreditUtilization

    """
    Returns some daily stats on the transform usage based on the data stored in the customer's
    SYSTEM datastream. Currently, we return only aggregate usage information. In the future, we will
    also return governor specific state.
    """
    transformRateLimitingStats(workspaceId: ObjectId!): TransformRateLimitingStats
}

enum CursorCacheMode @goModel(model: "observe/meta/metatypes.CursorCacheMode") {
    AlwaysCache
    AlwaysDontCache

    """
    This mode will cache the cursor if not all data is returned by the initial
    query. Specifically, cursor will be cached if any of the following
    conditions is true:
    1) initialRows != -1 && the query returns more rows than requested
    2) initialRows == -1 && the query returns rollup results and the rollup
    filter is not in "all" mode.
    """
    CacheIfMoreData
}

input PaginationInput @goModel(model: "observe/meta/metatypes.PaginationInput") {
    """
    Number of rows to return in paginatedResults of initial TaskResult. May
    be set to 0, in which case paginatedResults will only contain a cursor
    ID. Any value < 0 (say, -1) is interpreted as "all rows" (beware of
    large results).
    """
    initialRows: Int64!

    """
    Initial rollup filter (default to "all" mode if nil).
    """
    initialRollupFilter: RollupFilterInput

    """
    If set to true, cache the cursor so that Query.cursor() can be used to
    fetch additional rows beyond initialRows. Omitting or setting the
    parameter to false saves back-end resources and is to be preferred if
    the caller knows it will not call Query.cursor().
    """
    cacheCursor: Boolean @deprecated(reason:"use cursorCacheMode instead")

    """
    Choose how the cursor is cached.
    """
    cursorCacheMode: CursorCacheMode
}

enum TimeUnit @goModel(model: "observe/meta/metatypes.TimeUnit") {
    Second
    Millisecond
    Microsecond
    Nanosecond
}

input TimeSinceEpoch @goModel(model: "observe/meta/metatypes.TimeSinceEpoch") {
    value: Int64
    unit: TimeUnit
}

enum RateLimitOption @goModel(model: "observe/meta/metatypes.RateLimitOption") {
    """
    Default behavior. Rate limiting is enforced unless it is explicitly
    disabled at the customer or user level using some other mechanism.
    """
    EnforceRateLimit
    """
    Set this to bypass rate limiting for this query. Credits used by queries
    that bypass the rate limit are not counted towards the rate limit.
    """
    BypassRateLimit
}

"""
QueryParams are for parameters intrinsic to the *query*, not the *presentation*
of the query. One way to think about this, is that anything that goes in here
should be equally applicable to invocations by transformer, monitors, exports,
or worksheets.
"""
input QueryParams @goModel(model: "observe/meta/metagql.QueryParamsInput") {
    """
    Please specify exact one of startTime and startTimeSinceEpoch.
    """
    startTime: Time
    startTimeSinceEpoch: TimeSinceEpoch
    """
    Please specify exact one of endTime and endTimeSinceEpoch.
    """
    endTime: Time
    endTimeSinceEpoch: TimeSinceEpoch

    """
    Use this to specify rate limiting options for this query. To bypass the
    rate limit for all queries by this user for a certain amount of time, see
    the QueryGovernor.bypassUntil layered setting instead
    """
    rateLimitOption: RateLimitOption

    """
    Queries may have some parameter values bound
    """
    opalParameters: [ParameterBindingInput!] @deprecated(reason:"Use parameterValues instead")
}

"""
QueryParams are for parameters intrinsic to Live *query*, not the *presentation*
of the query. One way to think about this, is that anything that goes in here
should be equally applicable to invocations by transformer, monitors, exports,
or worksheets.
"""
input LiveQueryParams @goModel(model: "observe/meta/metagql.LiveQueryParamsInput") {
    """
    Live queries are run with a sliding query window where the end time is always
    the current time and the start time is derived through this duration. For instance,
    this can be "the last 5 minutes".
    """
    queryWindowSize: Duration!

    """
    Use this to specify rate limiting options for this query. To bypass the
    rate limit for all queries by this user for a certain amount of time, see
    the QueryGovernor.bypassUntil layered setting instead
    """
    rateLimitOption: RateLimitOption

    """
    Whether the query is run immediately once before waiting for data updates.
    """
    runImmediately: Boolean
}

# Scalar so we can use a custom marshaler for higher performance.
#
#type PaginatedResults {
#    # ID identifying the cursor. Can be used to fetch more rows.
#    cursorId: String
#    # Snowflake Query ID. Only for debugging.
#    sfQid: String
#    # Total number of rows that the cursor holds.
#    totalRows: Int64!
#    # Offset into the cursor from which the rows below have been produced,
#    # starting at 0.
#    offset: Int64!
#    # Number of rows in this result set.
#    numRows: Int64!
#    # Initial set of rows in column-major format. Each column contains exactly
#    # numRows values.
#    columns: [[String]]
#}
#
scalar PaginatedResults @goModel(model: "observe/meta/metatypes.PaginatedResults")

enum ExportFileFormat @goModel(model: "observe/meta/metatypes.ExportFileFormat") {
    """
    Comma Separated Values
    """
    Csv
    """
    Newline Delimited JSON
    """
    NDJson
}

type ExportCursorResult @goModel(model: "observe/meta/metatypes.ExportCursorResult") {
    """
    If the data from the cursor can be had by calling GET on a URL, this is
    the URL.
    """
    exportUrl: String!

    """
    The export URL will expire at some time in the future. This is that time.
    """
    exportUrlExpiration: Time

    """
    This is the filename you provided, or a generated filename if none was
    part of the request
    """
    exportFilename: String

    """
    This is the format you requested, or the default if none was part of the
    request
    """
    exportFormat: ExportFileFormat
}

"""
Results which are returned from subscription datasetLiveQuery all implement this interface.
"""
interface LiveQueryResult @goModel(model: "observe/meta/metaparser.LiveQueryResult") {
    # shared fields among all types of live mode results

    stageIdx: Int! @deprecated(reason: "identify stages by stageId instead")

    # TODO: Move query ID generation out of QueryManager and closer to the UI,
    # and make the field mandatory. We want to always provide users with a
    # query ID for bug reporting and investigations.
    """
    The Observe Query identifier
    """
    queryId: String!

    """
    This set of results pertains to the StageInput with this ID:
    """
    stageId: String #!<- make mandatory once stageIdx is removed @goField(name:StageID)

    # TODO: move ParsedPipeline.errors here?
    """
    Errors that apply to this stage as a whole rather than the OPAL. See
    parsedPipeline for OPAL-specific errors
    """
    errors: [TaskResultError!]
}

"""
Results returned from datasetProgressive and datasetQueryOutput.
Note that we want to split this type up into individual types per result kind, because this allows
to better specify (narrow down) which data is present in which result type.
To better constrain this, the individual result types (currently only TaskResult and LiveQueryFreshnessUpdateResult)
implement the interfaces of the subscriptions' / queries' result interfaces.
Currently the only interface is LiveQueryResult, but there will be more when we split up TaskResult.
"""
type TaskResult implements LiveQueryResult @goModel(model: "observe/meta/metaparser.TaskResult") {

    stageIdx: Int! @deprecated(reason: "identify stages by stageId instead")

    # TODO: Move query ID generation out of QueryManager and closer to the UI,
    # and make the field mandatory. We want to always provide users with a
    # query ID for bug reporting and investigations.
    """
    The Observe Query identifier
    """
    queryId: String!
    """
    This set of results pertains to the StageInput with this ID:
    """
    stageID: String @deprecated(reason: "use stageId instead")
    stageId: String#!<- make mandatory once stageIdx is removed @goField(name:StageID)

    """
    The time range which this set of results cover.
    """
    startTime: Time @deprecated(reason: "not used anymore")
    endTime: Time @deprecated(reason: "not used anymore")

    """
    If true, this is a progressive result and more results should come after
    this for this result kind. This flag does not apply to ResultKindProgress
    results, though.
    """
    isProgressive: Boolean! @deprecated(reason: "use resultMetadata.hasMoreResults")

    """
    if resultKind is resultKindProgress (which will only happen if it is one
    of the requested resultKinds for a stage), contains details on the task's
    progress
    """
    resultProgress: TaskResultProgress

    """
    You used to paginate the data yourself out of S3 -- not needed anymore
    """
    resultCursor: SnowflakeCursor @deprecated(reason: "use paginatedResults instead")
    """
    Read the results you asked for, through the apiserver
    """
    paginatedResults: PaginatedResults
    """
    if resultCursor is set, does it contain data or stats? Or if
    resultKindProgress, then resultProgress is set instead
    """
    resultKind: ResultKind

    """
    how to understand the columns in the result from Snowflake --
    """
    resultSchema: TaskResultSchema

    """
    Column stats results. Not null only if resultKind is ResultKindColumnStats
    """
    columnStats: ColumnStatsResults

    """
    Volume stats results. Not null only if resultKind is ResultKindVolumeStats
    """
    volumeStats: VolumeStatsResults

    """
    A parse/compile error is still a "successful" request, so HTTP status is OK,
    but the parse/compile error is pointed into the right part of the code in
    this result part.
    """
    parsedPipeline: ParsedPipeline

    comments: JsonObject
    # TODO: statistics for columns need to go here once we lift them out of
    # snowsql result

    estimatedCost: [CostMetric!]

    """
    A list of Datasets that have inlined when binding the tempo graph
    """
    inlinedDatasets: [Dataset!]

    """
    Metadata about the returned data and stats result. This must not be null for
    data and stats result.
    """
    resultMetadata: ResultMetadata

    # TODO: move ParsedPipeline.warnings here?
    """
    Warnings that apply to this stage as a whole rather than the OPAL. See
    parsedPipeline for OPAL-specific warnings
    """
    warnings: [TaskResultWarning!]

    # TODO: move ParsedPipeline.errors here?
    """
    Errors that apply to this stage as a whole rather than the OPAL. See
    parsedPipeline for OPAL-specific errors
    """
    errors: [TaskResultError!]

    """
    True if this is a TaskResult for
    - stats query whose data is sampled.
    - the sampled aggregation presentation option is enabled and sampling was applied.
    """
    isSampled: Boolean!

    """
    Search match metadata, returned for ResultKindData results if was requested
    in the StagePresentationInput.searchMatchKind
    """
    searchMatchMetadata: SearchMatchMetadata
}

type LiveQueryFreshnessUpdateResult implements LiveQueryResult @goModel(model: "observe/meta/metaparser.LiveQueryFreshnessUpdateResult") {

    stageIdx: Int! @deprecated(reason: "identify stages by stageId instead")

    # TODO: Move query ID generation out of QueryManager and closer to the UI,
    # and make the field mandatory. We want to always provide users with a
    # query ID for bug reporting and investigations.
    """
    The Observe Query identifier
    """
    queryId: String!

    """
    This set of results pertains to the StageInput with this ID:
    """
    stageId: String #!<- make mandatory once stageIdx is removed @goField(name:StageID)

    """
    Errors that apply to this stage as a whole,
    """
    errors: [TaskResultError!]

    """
    Update related to the data freshness.
    """
    freshnessUpdate: FreshnessUpdate!
}

type FreshnessUpdate @goModel(model: "observe/meta/metaparser.FreshnessUpdate") {
    """
    The latest ingestion time is the most recent time that we ingested
    new data that may influence (depending on the query) the
    query result.
    """
    latestIngestionTime: Time


    """
    The latest materialization time is the most recent time that the bottom most
    datasets for the given query were materializated. This may influence
    (depending on the query) the query result.
    """
    latestMaterializationTime: Time
}

type ColumnStatTopKValue @goModel(model: "observe/meta/metatypes.ColumnStatTopKValue") {
    """
    The value
    """
    value: String!
    """
    The number of times this value may appear in the column.
    """
    count: Int64!
    """
    A value between 0 and 1 to show how frequent this value may appear in the
    column.  1 means the value appears 100% of the time, while ~0 means the
    value almost never appears in the column (0 is not a valid value).
    """
    frequency: Float!
}

type ColumnStatHistogram @goModel(model: "observe/meta/metatypes.ColumnStatHistogram") {
    """
    Min value of the column
    """
    min: Float!
    """
    Max value of the column
    """
    max: Float!
    """
    Count of values within each bucket
    """
    buckets: [Int64!]!
}

type ColumnStats @goModel(model: "observe/meta/metatypes.ColumnStats") {
    column: String!
    """
    Top-K most frequent values. Null if disabled or unavailable.
    """
    topK: [ColumnStatTopKValue!]
    """
    Approximate number of distinct values. Null if disabled or unavailable.
    """
    distinctCount: Int64
    """
    Histogram of the values. Null if disabled or unavailable.
    """
    histogram: ColumnStatHistogram
}

type ColumnStatsResults @goModel(model: "observe/meta/metatypes.ColumnStatsResults") {
    """
    The number of rows that the stats are computed over. The semantic of the row
    limit is the same as the row limit in data request (i.e., top N rows based
    on the specific sorting orders).
    """
    rowCount: Int64!

    """
    Whether the stats results cover all data in the query results. If the field
    is true, one should assume that the returned stats are only an
    approximation, and can check the rowCount to find out how large the sample
    size is.
    """
    isSampled: Boolean!

    """
    Per column stats
    """
    stats: [ColumnStats!]!
}

type VolumeStatsResults @goModel(model: "observe/meta/metatypes.VolumeStatsResults") {
    """
    Volume stats may be disabled by the backend. If it is disabled, all other
    fields except disabledReason are null.
    """
    isDisabled: Boolean!

    """
    Reason for being disabled
    """
    disabledReason: String

    """
    Whether the stats results cover all data in the query results. If the field
    is true, one should assume that the returned stats are an approximation.
    """
    isSampled: Boolean

    """
    Size of each bucket
    """
    interval: Duration

    """
    Start time of the first bucket
    """
    base: Time

    """
    Number of rows within each bucket. This contains estimated values if isSampled is true.
    """
    buckets: [Int64!]

    """
    Total number of rows within the query window. This contains an estimated value if isSampled is true.
    """
    totalCount: Int64
}

type SearchMatchMetadata @goModel(model: "observe/meta/metatypes.SearchMatchMetadata") {
    """
    List of columns that have contributed to resulting data matching the search
    """
    columns: [String!]!
    """
    List of regexes to highlight the matches. There can be multiple elements for the same column
    """
    regexes: [SearchMatchColumnRegex!]!
}

type SearchMatchColumnRegex @goModel(model: "observe/meta/metatypes.SearchMatchColumnRegex") {
    column: String!
    regex: String!
    negated: Boolean!
}

type CostMetric @goModel(model: "observe/meta/metaparser.CostMetric") {
    name: String!
    value: Float
}

enum TaskState @goModel(model: "observe/meta/metaparser.TaskState") {
    """
    The query is being throttled by us for some reason, because the apiserver
    is handling too many requests already or the customer has issued too many
    queries
    """
    TaskStateQueued
    """
    The query is still being processed, either on our end or in snowflake.
    This covers everything from the query being compiled in the apiserver to
    the query being sent to the scheduler to the query being queued in
    snowflake.
    """
    TaskStatePreparing
    """
    The query is running in snowflake
    """
    TaskStateRunning
}

type TaskResultProgress @goModel(model: "observe/meta/metaparser.TaskResultProgress") {
    """
    Is this update for the data or stats part of this stage?
    """
    progressKind: ResultKind!

    """
    A task may have several subtasks, which subtask is currently running and
    how many are there in total? subtaskIdx is 0-indexed
    """
    subtaskIdx: Int!
    totalSubtasks: Int!

    """
    What is the state of the current subtask?
    """
    state: TaskState!

    """
    How many bytes has this subtask scanned so far and what is the upper
    bound on the total number of bytes it may have to scan? These are only
    set if the query is running. Note that it is possible for totalScanBytes
    to be 0 in some rare cases.
    """
    scannedBytes: Int64
    totalScanBytes: Int64
}

"""
TimeAlignment describes the temporal nature of the data contained in an Observe table.
It describes a periodic time grid with which all events/intervals in the table align
perfectly.
"""
type TimeAlignment @goModel(model: "observe/meta/metatypes.TimeAlignment") {
    """
    stepSize is the distance between every pair of adjacent points in the time grid.
    """
    stepSize: Duration!
    """
    offset describes the offset of this periodic time grid compare to epoch.
    It will be between [0, stepSize).
    """
    offset: Duration!
}

"""
AlignedTimeRange describes the validFrom of the first and last event/interval that should
be returned in an OPAL query, assuming that all time buckets have some data. This is only
populated when the query result aligns with a periodic time grid.
"""
type AlignedTimeRange @goModel(model: "observe/meta/metatypes.AlignedTimeRange") {
    leadingValidFrom: Time
    endingValidFrom: Time
}

type TaskResultSchema @goModel(model: "observe/meta/metatypes.TaskResultSchema") {
    """
    these fields are the same as for Dataset
    """
    validFromField: String
    validToField: String
    primaryKey: [String!]
    """
    This tracks how the primary keys of input datsets map to the current
    output, reusing the convenient ForeignKey type to do so
    """
    sourceResources: [ForeignKey!]
    keys: [[String!]!]
    foreignKeys: [ForeignKey!]
    relatedKeys: [RelatedKey!]
    groupingKey: GroupingKey
    correlationTagMappings: [CorrelationTagMapping!]
    """
    this is the same schema as Typedef.definition
    """
    typedefDefinition: JsonObject @deprecated(reason: "use the strong typed \"typedef\" field instead")
    typedef: ObjectTypedef @deprecated(reason: "use fieldList instead")
    fieldList: [FieldDesc!]
    labelField: String
    iconUrl: String
    kind: DatasetKind!
    interfaces: [ImplementedInterface!]! @goField(forceResolver:true)
    metrics: [Metric!]! @goField(forceResolver:true)
    accelerable: Boolean!
    streamable: Boolean! @deprecated(reason:"renamed to accelerable") @goField(name:accelerable)
    indexMetadata: IndexMetadata @deprecated(reason: "use fieldList.indexDefs instead")
    """
    alignment and alignedTimeRange are set when the produced result is on an
    aligned time grid. Both event table and interval/resource table can be aligned.
    """
    alignment: TimeAlignment
    alignedTimeRange: AlignedTimeRange

    """
    Information about the queried datasets. This is the same as the one in
    ResultMetadata but we need to send this back earlier as part of schema.
    """
    inputDatasetsInfo: [DatasetInfo!]
    """
    The accelerated windows of the query. This is the same as the one in
    ResultMetadata but we need to send this back earlier as part of schema.
    """
    acceleratedWindows: [TimeRange!]!
    """
    Information about the OPAL sort column ordering
    """
    sortColumnOrdering: [ColumnOrder!]

    """
    Information about the limit returned by the backend
    """
    limit: Int64
}

type ObjectTypedef @goModel(model: "observe/compiler/comptypes.ObjectTypedef") {
    anykey: Boolean
    fields: [ObjectFieldDef!]
    linkDesc: LinkSchema
}

"""
FieldDesc describes a field by its column name, its type, and a set of metadata properties.
"""
type FieldDesc @goModel(model: "observe/meta/metatypes.FieldDesc") {
    name: String
    type: FieldType!
    indexDefs: [IndexDefinition!]
    linkDesc: LinkSchema
    isNullable: Boolean
    isEnum: Boolean
    isSearchable: Boolean
    isHidden: Boolean
    isConst: Boolean
    isMetric: Boolean
}

"""
The FieldType contains a tag, which represents the underling type.
In the future, we may extend this with further properties.
"""
type FieldType @goModel(model: "observe/meta/metatypes.FieldType") {
    tag: DataType!
}

enum DataType @goModel(model: "observe/compiler/comptypes.ValueType") {
    """
    be explicit about the "empty" value for the null/unknown case
    """
    NONE

    # simple types

    BOOL
    FLOAT64
    INT64
    STRING
    TIMESTAMP
    DURATION
    IPV4

    # compound types

    ARRAY       # used to be ParameterKindList
    OBJECT    # there's not currently any object literals
    VARIANT   # there's not currently any need to put IN variants, only take them out of things
    LINK        # used to be ParameterKindResource

    # non-scalar types

    DATASETREF  # used to be ParameterKindInput
}

type LinkSchema @goModel(model: "observe/compiler/comptypes.LinkSchema") {
    targetDataset: Int64
    targetStageLabel: String
    targetLabelField: String
    label: String!
    srcFields: [String!]! @deprecated(reason: "use src instead")
    src: [LinkField!]
    dstFields: [String!]!
}
# To account for links from within objects, we need to store two parts -
# 1. column name
# 2. path within the object
type LinkField @goModel(model: "observe/compiler/comptypes.ColumnWithPath") {
    column: String!
    path: String
}

input LinkFieldInput @goModel(model: "observe/compiler/comptypes.ColumnWithPath") {
    column: String!
    path: String
}


type ObjectFieldType @goModel(model: "observe/compiler/comptypes.ObjectFieldType") {
    rep: String!
    def: ObjectTypedef
    nullable: Boolean
}

type ObjectFieldDef @goModel(model: "observe/compiler/comptypes.ObjectFieldDef") {
    name: String!
    type: ObjectFieldType!
    isEnum: Boolean
    isSearchable: Boolean
    isHidden: Boolean
    isConst: Boolean
    isMetric: Boolean
}

type ColumnOrder @goModel(model: "observe/meta/metatypes.ColumnOrder") {
    columnId: String!
    ascending: Boolean!
    nullOrdering: NullOrdering!
}

"""
Generic interface for a warning from a task result. Warnings are not fatal, and can be returned alongside query results.
"""
interface TaskResultWarning @goModel(model: "observe/meta/metatypes.TaskResultWarning") {
    """
    Warning type identifier, common for all warnings of the same type
    """
    messageTypeId: String!
    """
    Unique warning instance identifier
    """
    messageId: String!
    """
    Warning location in the pipeline
    """
    span: SourceSpan
    """
    Warning text, returned without any decorations like message type ID
    """
    text: String!
    """
    Warning message, can be decorated with warning type ID, source location and other bits
    """
    message: String!
}

"""
Warning that the customer is approaching the credit limit
"""
type TaskResultWarningRateLimit implements TaskResultWarning @goModel(model: "observe/meta/metatypes.TaskResultWarningRateLimit") {
    messageTypeId: String!
    messageId: String!
    """
    Warning location in the pipeline, never set for this type of warning
    """
    span: SourceSpan
    text: String!
    message: String!

    """
    Credits left in the credit budget and credits fraction that can be used right now
    """
    creditsRemainingInBudget: Float!
    creditsFractionRemainingInBudget: Float!
    """
    Info of whether the customer was throttled by the QCM
    """
    throttled: Boolean!
}

"""
Warning that there are some datasets cannot be bounded when compiling the opal.
"""
type TaskResultWarningBinding implements TaskResultWarning @goModel(model: "observe/meta/metatypes.TaskResultWarningBinding") {
    messageTypeId: String!
    messageId: String!
    """
    Warning location in the pipeline, never set for this type of warning
    """
    span: SourceSpan
    text: String!
    message: String!
}

"""
Reason to be returned as part of the DatasetStalenessInfo
"""
enum StalenessReason @goModel(model: "observe/meta/metatypes.StalenessReason") {
    CreditManagerOverride         # Staleness attributed to ACM override
    UnusedDatasetHibernating      # Staleness attributed to unused dataset freshness decay
    ConfiguredFreshnessGoal       # Staleness attributed to the set freshness goal
    SlowAcceleration              # Staleness attributed due to slow transform execution
}


"""
Warning that the query results are stale
"""
type TaskResultWarningStaleResults implements TaskResultWarning @goModel(model: "observe/meta/metatypes.TaskResultWarningStalenessResults") {
    messageTypeId: String!
    messageId: String!
    """
    Error location in the pipeline, never set for this type of warning
    """
    span: SourceSpan
    text: String!
    message: String!
    staleness: [DatasetStalenessInfo!]!
}

"""
Warning that a live mode session involves a source table type where we cannot speed up ingest.
One example is external table, where we cannot influence from the customer's POV how often new
data is ingested. For instance, the external Snowflake tables in O2 are updated by Snowflake
and we have no handle, except polling for new data more often.
"""
type TaskResultWarningLiveModeSource implements TaskResultWarning @goModel(model: "observe/meta/metatypes.TaskResultWarningLiveModeSource") {
    messageTypeId: String!
    messageId: String!
    """
    Error location in the pipeline, never set for this type of warning
    """
    span: SourceSpan
    text: String!
    message: String!
}

type DatasetStalenessInfo @goModel(model: "observe/meta/metatypes.DatasetStalenessInfo") {
    # TODO: At the moment we only offer this for datasets. We might need to introduce these
    # warnings also for monitors, e.g., for the Acceleration Manager
    datasetId: ObjectId!

    """
    How stale this dataset is
    """
    stalenessDuration: Duration!

    """
    Why this dataset is stale
    """
    stalenessReason: StalenessReason!
}


"""
Generic interface for an error from a task result. Errors are fatal and are returned in place of query results.
"""
interface TaskResultError @goModel(model: "observe/meta/metatypes.TaskResultError") {
    """
    Error type identifier, common for all errors of the same type
    """
    messageTypeId: String!
    """
    Unique error instance identifier
    """
    messageId: String!
    """
    Error location in the pipeline
    """
    span: SourceSpan
    """
    Error text, returned without any decorations like message type ID
    """
    text: String!
    """
    Error message, can be decorated with message type ID, source location and other bits
    """
    message: String!
}

"""
A generic error type to return legacy errors in that do not have more specific types yet
"""
type TaskResultErrorGeneric implements TaskResultError @goModel(model: "observe/meta/metatypes.TaskResultErrorGeneric") {
    messageTypeId: String!
    messageId: String!
    span: SourceSpan
    text: String!
    message: String!
}

"""
A generic error type to return legacy warnings in that do not have more specific types yet
"""
type TaskResultWarningGeneric implements TaskResultWarning @goModel(model: "observe/meta/metatypes.TaskResultWarningGeneric") {
    messageTypeId: String!
    messageId: String!
    span: SourceSpan
    text: String!
    message: String!
}

"""
An error returned when a stage cannot be compiled because it forms a dependency loop with some of its inputs
"""
type TaskResultErrorStageDependencyLoop implements TaskResultError @goModel(model: "observe/meta/metatypes.TaskResultErrorStageDependencyLoop") {
    messageTypeId: String!
    messageId: String!
    span: SourceSpan
    text: String!
    message: String!
    """
    ID of the stage that triggered an error
    """
    firstStageId: String!
    """
    IDs of all the stages forming a loop, firstStageId must be among them
    """
    stageIds: [String!]!
}

"""
An error returned when a stage cannot be compiled because input stages have errors
"""
type TaskResultErrorStageHasDependenciesWithErrors implements TaskResultError @goModel(model: "observe/meta/metatypes.TaskResultErrorStageHasDependenciesWithErrors") {
    messageTypeId: String!
    messageId: String!
    span: SourceSpan
    text: String!
    message: String!
    """
    ID of the stage that triggered an error
    """
    stageId: String!
    """
    List of errors found in the upstream stages
    """
    upstreamStageErrors: [StageErrors!]!
}

"""
Errors found in a given stage
"""
type StageErrors @goModel(model: "observe/meta/metatypes.StageErrors") {
    stageId: String!
    errors: [TaskResultError!]!
    """
    Tells if this stage is an "error root", meaning it has errors but no other
    upstream stages have errors
    """
    isErrorRoot: Boolean!
}

"""
Error that the query was blocked or throttled due to the query rate limit set for this customer
"""
type TaskResultErrorRateLimit implements TaskResultError @goModel(model: "observe/meta/metatypes.TaskResultErrorRateLimit") {
    messageTypeId: String!
    messageId: String!
    """
    Error location in the pipeline, never set for this type of error
    """
    span: SourceSpan
    text: String!
    message: String!

    """
    Credits left in the credit budget that can be used right now, or null if no
    rate limit is configured
    """
    creditsRemainingInBudget: Float!

    """
    Query resulted in an error because it was hard limit blocked or not. Currently if true, we don't
    run the query and if false, the query was run but timed out because it was throttled i.e. downlaned
    and shorter timeout.
    """
    hardLimitBlocked: Boolean!
}

"""
Error that a stage fails to bind the dataset to the physical table (i.e., fail
to inline or use best effort binding).
"""
type TaskResultErrorBinding implements TaskResultError @goModel(model: "observe/meta/metatypes.TaskResultErrorBinding") {
    messageTypeId: String!
    messageId: String!
    """
    Error location in the pipeline, never set for this type of error
    """
    span: SourceSpan
    text: String!
    message: String!
}

"""
Base interface for all index types.
"""
interface IndexDefinition @goModel(model: "observe/meta/metatypes.IndexDefinition") {
    column: String!
} 

type TokenIndex implements IndexDefinition @goModel(model: "observe/meta/metatypes.TokenIndex") {
    column: String!
}

type SubstringIndex implements IndexDefinition @goModel(model: "observe/meta/metatypes.SubstringIndex") {
    column: String!
}

type EqualityIndex implements IndexDefinition @goModel(model: "observe/meta/metatypes.EqualityIndex") {
    column: String!
}

"""
Metadata for data and stats result.
"""
type ResultMetadata @goModel(model: "observe/meta/metatypes.ResultMetadata") {
    """
    If true, more TaskResults are expected. This will replace
    TaskResult.isProgressive. This is mostly used in progressive execution where
    multiple TaskResults could be returned for the same query.
    """
    hasMoreResults: Boolean!

    """
    If true, the query is running incrementally. This means that there will be
    more frequent updates to the result set. Each update replaces the results
    that have been already delivered so far.
    """
    isIncremental: Boolean!

    """
    Queries that are executed in multiple parts will report how many time slices
    have been executed so far.
    """
    incrementalSliceNumber: Int

    """
    The number of parallel incremental tasks that are used at this stage of
    the query.
    """
    incrementalParallelism: Int

    """
    The actual windows of returned data.
    """
    effectiveWindows: [TimeRange!]!

    """
    The accelerated windows of the query.
    """
    acceleratedWindows: [TimeRange!]!

    """
    Information about the queried datasets.
    """
    inputDatasetsInfo: [DatasetInfo!]

    """
    Information about the accessed indexes.
    """
    accessedIndexes: [IndexDefinition!] 
    }


type DatasetInfo @goModel(model: "observe/meta/metatypes.DatasetInfo") {
    datasetId: ObjectId!
    datasetLabel: String

    """
    True if this is a dataset brought in through linkify. Otherwise it's an
    input dataset directly referenced in the query.
    """
    datasetIsLinkifyInput: Boolean!

    """
    On-demand materialization length (in nanoseconds) for this dataset.
    """
    onDemandMatLen: Int64!

    """
    List of the missing intervals for which the dataset is queried for but not
    accelerated. These are the intervals we need to request for materialization
    (in the future, when we have the corresponding API). The missing intervals
    are always calculated using the original query window (not the smaller query
    window for progressive slices). This is non-empty only when canAccelerate is
    true.
    """
    unacceleratedWindows: [TimeRange!]
}

"""
What pieces of result to include in the response to an OPAL query.
"""
enum ResultKind @goModel(model: "observe/meta/metaparser.ResultKind") {
    ResultKindSchema      # Return the schema of the OPAL query
    ResultKindData        # Return the data of the OPAL query
    ResultKindStats       @deprecated(reason:"use ResultKindColumnStats and/or ResultKindVolumeStats")
    ResultKindColumnStats # Return column stats on the data of the OPAL query
    ResultKindVolumeStats # Return volume stats on the data of the OPAL query
    ResultKindSuppress    # Don't execute/return results
    ResultKindProgress    # Return the progress of the OPAL query
    ResultKindMetricDiscovery # Return a schema of the OPAL query with discovered metric information (MetricHeuristics) attached
}

input StageInput @goModel(model: "observe/meta/metaparser.StageInput") {
    """
    unique ID that other stages can reference in their InputDefinitionInput
    """
    stageId: String! @goField(name:StageID)
    """
    What is the description of this stage (stage name)
    """
    description: String @deprecated(reason:"use metadata.description")
    """
    What component feature is this stage driving? i.e. filter bar, visualization etc.
    """
    component: String @deprecated(reason:"use metadata.component")
    """
    Which inputs are defined for this stage?
    """
    inputs: [InputDefinitionInput!]!
    """
    What is the processing?
    """
    pipeline: String!
    """
    How do we arrange presentation? (ordering etc)
    Note that later stages referencing this stage will NOT see the stage presentation processing
    """
    presentation: StagePresentationInput
    """
    UI presentation data to use when storing transforms
    """
    layout: JsonObject
    """
    If set, enables paginatedResults in initial TaskResult of ResultKindData.
    """
    pagination: PaginationInput
    """
    If set, run this stage with progressive execution
    """
    progressive: Boolean
    """
    If set and progressive is also set, we will try to run the query incrementally
    """
    incremental: Boolean @deprecated(reason: "this is work in progress; will be removed")
    """
    If set, backend will try to run this stage with best effort binding mode
    """
    bestEffortBinding: Boolean
    """
    A location within the pipeline. Used to support "run query up to cursor" type functionality, where this location
    defines the last verb within the query or subquery to run.
    """
    runUntilLocation: SourceLocInput
    """
    Parameter values for parameters scoped to this stage
    """
    parameterValues: [ParameterBindingInput!]
    """
    Additional metadata about the stage. Should not change the behavior of the query, and should
    merely provide more context about how and where the stage is being used.
    """
    metadata: StageMetadata
}

"""
Parameter values for queries (and defaults) are specified with
ParameterBindingInput.

For APIs that take a raw StageInput array, the parameterValues argument is in
parallel.  For APIs that take MultiStageQueryInput, parameterValues are part
of that query.
"""
input ParameterBindingInput @goModel(model: "observe/compiler/comptypes.ParameterBinding") {
    id: String!
    value: ValueInput!
}

type ParameterBinding @goModel(model: "observe/compiler/comptypes.ParameterBinding") {
    id: String!
    value: Value!
}

"""
These are the OPAL native types that can go into worksheet parameters.  Some
of the native OPAL types aren't (currently?) exposed to the worksheet
parameters, but it's likely we will expand this to the full roster over time.
Also, there will be other places where we send "values" into the API. For
example, we've dodged it so far in places like monitors, by saying "threshold
is always float, and facet is always string," but a generic monitor
specification should absolutely use ValueInput / ValueType.
"""
enum ValueType @goModel(model: "observe/compiler/comptypes.ValueType") {
    """
    be explicit about the "empty" value for the null/unknown case
    """
    NONE

    # simple types

    BOOL
    FLOAT64
    INT64
    STRING
    TIMESTAMP
    DURATION
    
    # compound types

    ARRAY       # used to be ParameterKindList
    # OBJECT    # there's not currently any object literals
    # VARIANT   # there's not currently any need to put IN variants, only take them out of things
    LINK        # used to be ParameterKindResource

    # non-scalar types

    DATASETREF  # used to be ParameterKindInput
}

"""
The ValueInput specifies a value for a parameter. To specify a null value, specify
the particular field, but with the JSON value null. This is needed because values
are always of a particular type, and a generic null is not typed.
"""
input ValueInput @goModel(model: "observe/compiler/comptypes.ValueInstance") {
    bool: Boolean
    float64: Float
    int64: Int64
    string: String
    timestamp: Time @goField(forceResolver: true)
    duration: Int64 @goField(forceResolver: true)
    array: ValueArrayInput
    link: ValueLinkInput
    datasetref: ValueDatasetrefInput
}

input PrimitiveValueInput @goModel(model: "observe/compiler/comptypes.ValueInstance") {
    bool: Boolean
    float64: Float
    int64: Int64
    string: String
    timestamp: Time @goField(forceResolver: true)
    duration: Int64 @goField(forceResolver: true)
}

type Value @goModel(model: "observe/compiler/comptypes.ValueInstance") {
    bool: Boolean
    float64: Float
    int64: Int64
    string: String
    timestamp: Time @goField(forceResolver: true)
    duration: Int64 @goField(forceResolver: true)
    array: ValueArray
    link: ValueLink
    datasetref: ValueDatasetref
}

type PrimitiveValue @goModel(model: "observe/compiler/comptypes.ValueInstance") {
    bool: Boolean
    float64: Float
    int64: Int64
    string: String
    timestamp: Time @goField(forceResolver: true)
    duration: Int64 @goField(forceResolver: true)
}

input ValueArrayInput @goModel(model: "observe/compiler/comptypes.ValueArray") {
    value: [PrimitiveValueInput!]!
}

type ValueArray @goModel(model: "observe/compiler/comptypes.ValueArray") {
    value: [PrimitiveValue!]!
}

input ValueLinkInput @goModel(model: "observe/compiler/comptypes.ValueLink") {
    datasetId: ObjectId!
    primaryKeyValue: [ValueKeyValueInput!]!
    storedLabel: String
}

type ValueLink @goModel(model: "observe/compiler/comptypes.ValueLink") {
    datasetId: ObjectId!
    primaryKeyValue: [ValueKeyValue!]!
    storedLabel: String
}

input ValueKeyValueInput @goModel(model: "observe/compiler/comptypes.ValueKeyValue") {
    name: String!
    value: PrimitiveValueInput!
}

type ValueKeyValue @goModel(model: "observe/compiler/comptypes.ValueKeyValue") {
    name: String!
    value: PrimitiveValue!
}

"""
ValueDatasetrefInput looks a bit like InputDefinitionInput, EXCEPT
you can't specify a parameterId as the value of a ValueDatasetrefInput
(because that would make little sense.)
"""
input ValueDatasetrefInput @goModel(model: "observe/compiler/comptypes.ValueDatasetref") {
    datasetId: ObjectId
    datasetPath: String
    stageId: String
}

type ValueDatasetref @goModel(model: "observe/compiler/comptypes.ValueDatasetref") {
    datasetId: ObjectId
    datasetPath: String
    stageId: String
}

input ValueTypeSpecInput @goModel(model: "observe/compiler/comptypes.ValueTypeSpec") {
    type: ValueType!
    arrayItemType: ValueTypeSpecInput
    keyForDatasetId: ObjectId
}

type ValueTypeSpec @goModel(model: "observe/compiler/comptypes.ValueTypeSpec") {
    type: ValueType!
    arrayItemType: ValueTypeSpec
    keyForDatasetId: ObjectId
}

input ValueKeyTypeInput @goModel(model: "observe/compiler/comptypes.ValueKeyType") {
    name: String!
    type: ValueTypeSpecInput!
}

type ValueKeyType @goModel(model: "observe/compiler/comptypes.ValueKeyType") {
    name: String!
    type: ValueTypeSpec!
}

"""
Whever you can "save" a worksheet-like entity, you can also save the
parameters that go with it. This is so that the worksheet component in the FE
can have a unified API to work against. You can also save the parameterValues
to go with it as well.
"""
input ParameterSpecInput @goModel(model: "observe/meta/metatypes.ParameterSpec") {
    """
    opal usable id, ideally a valid C and JavaScript identifier
    """
    id: String!
    """
    user-readable name
    """
    name: String!
    """
    optional default value, must match valueKind if present
    """
    defaultValue: ValueInput
    valueKind: ValueTypeSpecInput!
}

type ParameterSpec @goModel(model: "observe/meta/metatypes.ParameterSpec") {
    id: String!
    name: String!
    """
    optional default value
    """
    defaultValue: Value
    valueKind: ValueTypeSpec!
}

"""
Why do we separate "Data" bindings from "Reference" bindings? Why does this
have to be pre-declared, rather than resolved at the end by the compiler?

Because we have the hard rule that physical dataset IDs only exist in the
API, not at the OPAL level, we wouldn't know which particular dataset you'd
suggest to use, unless the input binding was pre-declared.  If we just made
something up in GetTargetDatasetBinding() then how would we later know which
shape to resolve it to?

The user writes addfk "some name", id=@theThing.id

We need to know what theThing really means. Hence, it needs a binding. Hence,
when bindings are specified, we need to know whether you expect that to be
100% defined, or left pending.  We could allow a less concrete pipeline
specification. Leave @theThing entirely unresolved, and only resolve it using
some later operation that says "and wherever I called something @theThing,
now I mean this thing!" (edited)

Which means that we have to live with pipelines that are constantly in
unresolved and unresolvable states, and only some pipelines can run. We also
can no longer preview the data until that next step has been taken.

I e, we assume each query (set of stages) compiles and links as a unit. There
is no separate compilation, because the user experience and complexity of
that abstraction seems unnecessary just to solve this one use case in this
one alternative way.
"""
enum InputRole @goModel(model: "observe/meta/metatypes.InputRole") {
    Default
    Data
    Reference
}

type InputDefinition @goModel(model: "observe/meta/metatypes.InputDefinition") {
    """
    Assign the short and unique user mnemonic for this input, used in @tableref expressions
    """
    inputName: String!
    inputRole: InputRole!
    """
    One of the input definition fields is used; the others are null
    because GO doesn't have unions.
    """
    datasetId: ObjectId
    datasetPath: String
    stageID: String @deprecated(reason: "use stageId")
    """
    Only set stageId to reference input that comes from an actual stage in the same query
    """
    stageId: String @goField(name:StageID)
}

input InputDefinitionInput @goModel(model: "observe/meta/metatypes.InputDefinition") {
    """
    Assign the short and unique user mnemonic for this input, used in @tableref expressions
    """
    inputName: String!
    """
    If this input is to be used for a purpose other than "slurp data," then specify that here.
    """
    inputRole: InputRole

    """
    Datasets defined by IDs refer to latest-published version of dataset.
    """
    datasetId: ObjectId

    """
    Format of datasetPath is projectlabel.datasetlabel
    """
    datasetPath: String

    """
    Reference a previous query in the worksheet by label
    """
    stageID: String @deprecated(reason: "use stageId")
    stageId: String @goField(name:StageID)

    """
    If this input is parameterized, this will contain the ID of the parameter to substitute for this input. Parameters
    are bound in the QueryParams for the query being issued with this input.
    """
    parameterId: String
}

"""
StagePresentationInput is about how to format the results of the query. Here is
where you can ask for things like linkified results, rolled up results, stats
from the results, schema-only results, and so forth. These requests are
generally made by interactive systems, and are not generally applicable to
other use cases.
"""
input StagePresentationInput @goModel(model: "observe/meta/metaparser.StagePresentationInput") {
    """
    limit can be per-query in addition to per-request; the min() is applied
    """
    limit: Int64
    """
    columnStats configuration
    """
    columnStats: ColumnStatsInput
    """
    volumeStats configuration
    """
    volumeStats: VolumeStatsInput
    """
    orderColumns determines order of returned data rows
    """
    orderColumns: [ColumnOrderInput!]
    """
    when linkify is true, the server will resolve all declared foreign keys
    and create one new field for each containing that user-readable name of the
    target of the key (see design doc in Notion)
    """
    linkify: Boolean
    """
    Specifies the options for rollup presentation.
    """
    rollup: RollupOptionInput
    """
    rollupMode, if specified, overrides rollup.
    Always: Roll up the result, grouping by primary key if possible,
    otherwise by grouping all rows together.
    Never: Don't roll up the result.
    Auto: Roll up the result if it is a Resource, otherwise don't roll up
    the result.
    """
    rollupMode: RollupMode
    """
    resultKinds map to which fields of TaskResult will end up containing
    information in results (when using datasetProgressive for querying.) Note that not
    all the fields may be set at the same time, data may be split across
    multiple separate TaskResult structs in the result stream. However, in
    aggregate, all the data requested in resultKinds will be responded.
    """
    resultKinds: [ResultKind!]
    """
    When wantBuckets is set, time-binning verbs without explicit resolution specification
    will automatically find a human-friendly resolution and generate the wanted number of
    buckets. When exact number of buckets is not possible, more buckets will be generated.
    """
    wantBuckets: Int64
    """
    When set to SearchMatchColumns, TaskResult.TODO for ResultKindData responses
    will contain a list of column names that produced matches for some of the filters in
    the pipeline
    """
    searchMatchKind: SearchMatchKind
    """
    Specifies the aggregation mode. Default is `Precise`.
    """
    aggregationMode: AggregationMode

    """
    This field is deprecated and will be ignored, but cannot be removed because
    Terraform provider depends on it.
    """
    defaultStats: DefaultStatsInput @deprecated(reason:"Use columnStats and/or volumeStats")
}

"""
Deprecated, and will return entirely empty result. Use ColumnStatsInput and/or VolumeStatsInput instead.
We cannot remove it because the Terraform provider depends on it.
"""
input DefaultStatsInput @goModel(model: "observe/meta/metaparser.DefaultStatsInput") {
    """
    This field is deprecated and will be ignored
    """
    topKCount: Int64 @deprecated(reason:"use ColumnStatsInput.topKCount")
    """
    This field is deprecated and will be ignored
    """
    maxNbHistograms: Int64 @deprecated(reason:"use ColumnStatsInput.maxNbHistograms")
    """
    This field is deprecated and will be ignored
    """
    histogramCount: Int64 @deprecated(reason:"use ColumnStatsInput.histogramBucketCount")
    """
    This field is deprecated and will be ignored
    """
    sparklineBucketCount: Int64 @deprecated(reason:"use VolumeStatsInput.bucketCount")
    """
    This field is deprecated and will be ignored
    """
    sparklineFunction: String @deprecated(reason:"DefaultStatsInput is deprecated")
    """
    This field is deprecated and will be ignored
    """
    includeTimestampColumns: Boolean @deprecated(reason:"DefaultStatsInput is deprecated")
    """
    This field is deprecated and will be ignored
    """
    useCompoundTopKForLinks: Boolean @deprecated(reason:"use ColumnStatsInput.useCompoundTopKForLinks")
}

enum AggregationMode @goModel(model: "observe/compiler/comptypes.AggregationMode") {
    """
    Run the query without sampling.
    """
    Precise,
    """
    Run the query with sampled aggregation enabled. The result is not
    guaranteed to be sampled.
    """
    Sampled
}

enum RollupMode @goModel(model: "observe/compiler/comptypes.RollupMode") {
    """
    Roll up the result, grouping by primary key if possible,
    otherwise by grouping all rows together.
    """
    Always,
    """
    Don't roll up the result.
    """
    Never,
    """
    Roll up the result if it is a Resource, otherwise don't roll up the result.
    """
    Auto,
    """
    Roll up the result (by returning the last value + a bit describing whether
    the value changed during the query window) if it is a Resource, otherwise
    dont roll up the result
    """
    LastValueAndChanged,
}

enum SearchMatchKind @goModel(model: "observe/meta/metatypes.SearchMatchKind") {
    """
    Search match  data is not needed
    """
    SearchMatchNone,
    """
    Send back a list of columns that have contributed to resulting data matching the search
    """
    SearchMatchColumns
}

input RollupOptionInput @goModel(model: "observe/meta/metaparser.RollupOptionInput") {
    """
    If maxRowsPerGroup is set, rollup presentation will respect it as the limit for maximum number
    of points allowed for each group; otherwise, rollup presentation will use heuristics to propose
    a limit (typically 400 or 2000).
    Either way, rollup presentation limits each group to this size, and apply sampling preemptively.
    """
    maxRowsPerGroup: Int64

    """
    If unrollColumns is set, the columns specified will be unrolled after being
    grouped by primary key and ordered by time. Empty unrollColumns will produce
    1 row for each primary key (because all non-primary key columns are rolled
    up). If a column C having values [0,1,0] at times [0,1,2] for a given primary
    key is specified in unrollColumns, 3 rows will be produced for that primary
    key, with the values of C being 0, 1, 0 in each row, respectively.
    """
    unrollColumns: [String!] @deprecated(reason:"only used in niche scenarios, not worth the complexity")

    """
    If set to true, explicitly disables rollup, even for a Resource
    """
    forceNoRollup: Boolean @deprecated(reason:"use StagePresentationInput.rollupMode instead")
}

input ColumnStatsInput @goModel(model: "observe/meta/metatypes.ColumnStatsInput") {
    """
    Something which is a string, or which is inferred to be an ID, will
    return a list of the top K values + counts
    """
    topKCount: Int64

    """
    Whether to generate compound TopK for link columns. Note that this will
    disable the normal TopK results for link columns.
    """
    useCompoundTopKForLinks: Boolean

    """
    Maximum number of histograms to return.

    Integer, float, duration columns return histograms.

    Set to 0 to disable histograms.
    Set to <0 for an unlimited number of histograms.
    Set to null to let the backend decide a suitable limit.
    """
    maxNbHistograms: Int64

    """
    Number of buckets per histogram.

    Set to 0 to disable histograms.
    Set to null to let the backend decide.
    """
    histogramBucketCount: Int64

    """
    Whether to compute distinct value count per column. This applies to string
    column or column inferred to be an ID. null or false would disable it.
    """
    needDistinctCount: Boolean
}

input VolumeStatsInput @goModel(model: "observe/meta/metatypes.VolumeStatsInput") {
    """
    Number of buckets to compute the volume over time.
    Set to 0 to disable volume over time stats.
    Set to null to let the backend decide.
    """
    bucketCount: Int64

    """
    Whether to compute the total number of rows. null or false would disable it.
    """
    needTotalCount: Boolean
}

enum NullOrdering @goModel(model: "observe/meta/metatypes.NullOrdering") {
    """
    Default: nulls are "small" for valid-from, "big" for valid-to, and "last"
    for other fields.
    """
    Default,
    First,
    Last
}

input ColumnOrderInput @goModel(model: "observe/meta/metatypes.ColumnOrderInput") {
    columnName: String!
    """
    default is descending, which is great for timestamps
    """
    ascending: Boolean
    nullOrdering: NullOrdering
}

enum RollupFilterMode @goModel(model: "observe/meta/metatypes.RollupFilterMode") {
    Last
    All
}

input RollupFilterInput @goModel(model: "observe/meta/metatypes.RollupFilterInput") {
    mode: RollupFilterMode!

    # TODO: add more sophisticated filter options, like time range-based filtering.
}

"""
Well-known stats column.
"""
enum StatsWKCol @goModel(model: "observe/meta/metastats.WKCol") {
    BucketId
    BucketHash
    CountStar
}

"""
Small materialized aggregates (SMAs).
"""
enum StatsSMA @goModel(model: "observe/meta/metastats.SMA") {
    Count
    Min
    Max
    CountDistinct
    Size
    Minhash
}

"""
A query fragment for a single SMA of some dataset.
"""
input StatsSMAQueryInput @goModel(model: "observe/meta/metastats.SMAQuery") {
    sma: StatsSMA!
    inColNames: [String!]!
}

"""
A query fragment that contains all the StatsSMAQueryInput fragments that
belong to a common base dataset.
"""
input StatsDatasetQueryInput @goModel(model: "observe/meta/metastats.DatasetQuery") {
    baseDatasetId: ObjectId
    baseDatasetPath: String
    smaQueries: [StatsSMAQueryInput!]
}

"""
A StatsQueryResult fragment that corresponds to a single
StatsDatasetQueryInput.
"""
type StatsDatasetQueryResult @goModel(model: "observe/meta/metastats.DatasetResult") {
    validFromCol: [Number!]
    validToCol: [Number!]
    wkCols: [StatsVector!]
    smaCols: [StatsVector!]
    smasCombined: [Any!]
}

"""
A complete stats result that corresponds to a stats() query. May contain
multiple StatsDatasetQueryResult.

Not to be confused with the stats result for some dataset() query.
"""
type StatsQueryResult @goModel(model: "observe/meta/metastats.Result") {
    queryId: String!
    dsResults: [StatsDatasetQueryResult]!
}

enum QueryRateLimitingState @goModel(model: "observe/meta/metatypes.QueryRateLimitingState") {
    """
    The query governor is configured and enforced, but we are not at any limits
    """
    Ok

    """
    The query governor has not been configured, e.g. it is disabled
    """
    NotConfigured

    SoftLimit
    HardLimit
}

enum ThrottledInfo @goModel(model: "observe/meta/metatypes.ThrottledInfo") {
    """
    The query governor is configured and throttling the customer
    """
    Throttled

    """
    The query governor is configured and is not throttling the customer
    """
    NotThrottled
}

type QueryRateLimitAndUsageDetails @goModel(model: "observe/meta/metatypes.QueryRateLimitAndUsageDetails") {

    """
    The scope (Customer or User) to which the limits or credit usage counts apply.
    """
    scope: String!

    """
    Credits left in the credit budget for the specified scope that can be used right now, or null if
    no rate limit is configured
    """
    creditsRemainingInBudget: Float

    """
    Maximum total number of credits in the credit budget for this scope, or null if
    no rate limit is configured. Note: In general, the QCM will be a in a particular state if
    maxCreditsInBudget - creditsRemainingInBudget > respectiveLimit (for either user or customer).
    """
    maxCreditsInBudget: Float

    """
    Credits used in the past 24 hours until now for the scope
    """
    creditsUsedPast24Hours: Float!

    """
    Credits used over the past 7 days for the scope
    """
    creditsUsedPast7Days: Float!

    """
    Credits used over the past 30 days for the scope
    """
    creditsUsedPast30Days: Float!

    """
    Total credits available for the time horizon for the scope. Null if no limit is set.
    """
    creditLimit: Float

    """
    Total credits available for the time horizon for the scope before throttling. 
    Null if not limit is set.
    """
    throttledCreditLimit: Float

    """
    The time horizon that limits apply over
    """
    timeHorizon: Duration!
}

type QueryRateLimitingStats @goModel(model: "observe/meta/metatypes.QueryRateLimitingStats") {
    """
    Current rate limiting state for this user.

    The user may be limited based on customer or user level limits.
    """
    state: QueryRateLimitingState!

    """
    Credits left in the _customer_ credit budget that can be used right now, or null if no
    rate limit is configured

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].creditsRemainingInBudget where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    creditsRemainingInBudget: Float

    """
    Maximum total number of credits in the _customer_ credit budget, or null if
    no rate limit is configured. Note: In general, the QCM will be a in a particular state if
    maxCreditsInBudget - creditsRemainingInBudget > respectiveLimit (for either user or customer).

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].maxCreditsInBudget where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    maxCreditsInBudget: Float

    """
    Current throttling Info for the user, null if QCM is not configured.

    The user may be throttled due to either customer or user limits;
    see limitAndUsageDetailsPerScope for credit usage and limits for
    the customer and user scope individually.
    """
    throttleMode: ThrottledInfo

    """
    Credits used in the past 24 hours until now for the _customer_.

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].creditsUsedPast24Hours where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    creditsUsedPast24Hours: Float!

    """
    Daily average credits used over the past 7 days for the _customer_.

    Raw credit usage information for the 7 day period is available in
    limitAndUsageDetailsPerScope[i].creditsUsedPast7Days where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    dailyAvgCreditUsagePast7Days: Float!

    """
    Daily average credits used over the past 30 days for the customer

    Raw credit usage information for the 30 day period is available in
    limitAndUsageDetailsPerScope[i].creditsUsedPast30Days where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    dailyAvgCreditUsagePast30Days: Float!

     """
    Total credits available for each day for the _customer_. Null if no limit is set.

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].creditLimit where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    dailyCreditLimit: Float

    """
    Total contract credits available for each day for the customer. Null if no limit is set.
    """
    dailyContractCreditLimit: Float

    """
    Total throttled credits available for each day. Null if not limit is set.

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].throttledCreditLimit where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    dailyThrottledCreditLimit: Float

    """
    The details of credit usage and limits for all scopes that have applicable limits.

    NOTE - this in general will return an entry for all scopes - but limits may be missing if not
    set. This is so that credit usage / billing information is returned.
    """
    limitAndUsageDetailsPerScope: [QueryRateLimitAndUsageDetails!]!
    
}

type QueryWeeklyCreditUtilization @goModel(model: "observe/meta/metatypes.QueryWeeklyCreditUtilization") {
    """
    Current rate limiting state for this user.

    The user may be limited based on customer or user level limits.
    """
    state: QueryRateLimitingState!

    """
    Credits left in the _customer_ credit budget that can be used right now, or null if no
    rate limit is configured

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].creditsRemainingInBudget where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    creditsRemainingInBudget: Float

    """
    Maximum total number of customer credits in the credit budget, or null if
    no rate limit is configured. Note: In general, the QCM will be a in a particular state if
    maxCreditsInBudget - creditsRemainingInBudget > respectiveLimit (for either customer or user)
    
    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].maxCreditsInBudget where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    maxCreditsInBudget: Float

    """
    Current throttling Info for the user, null if QCM is not configured.

    The user may be throttled based on customer or user level limits.
    """
    throttleMode: ThrottledInfo

    """
    Total credits used over the past 7 days for the customer

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].creditsUsedPast7Days where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    creditUsagePast7Days: Float!

    """
    Total credits available for each week for the customer. Zero if no limit is set.

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].creditLimit where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    weeklyCreditLimit: Float!

    """
    Total contract credits available for each week for the customer. Zero if no limit is set.
    """
    weeklyContractCreditLimit: Float!

    """
    Total credits available for each week for the customer before throttling. Zero if not limit is set.

    This field is deprecated - and in future should be replaced with 
    limitAndUsageDetailsPerScope[i].throttledCreditLimit where
    limitAndUsageDetailsPerScope[i].scope == "Customer".
    """
    weeklyThrottledCreditLimit: Float!

    """
    The details of credit usage and limits for all scopes that have applicable limits.

    NOTE - this in general will return an entry for all scopes - but limits may be missing if not
    set. This is so that credit usage / billing information is still returned.
    """
    limitAndUsageDetailsPerScope: [QueryRateLimitAndUsageDetails!]!

}

type TransformRateLimitingStats @goModel(model: "observe/meta/metatypes.TransformRateLimitingStats") {
    """
    Returns the daily ongoing transform credit usage for the past 7 days. Note that if the customer
    has been active for less than 7 days, the time horizon for the computation is restricted to the
    actual timeframe in which the customer was active.
    """
    dailyOngoingTransformCreditsUsedPast7Days: Float!

    """
    Returns the daily ongoing transform credit usage for the past 30 days. Note that if the customer
    has been active for less than 30 days, the time horizon for the computation is restricted to the
    actual timeframe in which the customer was active.
    """
    dailyOngoingTransformCreditsUsedPast30Days: Float!
}

"""
Metadata a client can send together with an observe query. Should not change the
behavior of the query, and should only provide some context around what this
query is used for.
"""
input QueryMetadata @goModel(model: "observe/meta/metatypes.QueryMetadata") {
    """
    Observe site URL where the query is triggered
    """
    url: String

    """
    Observe page type (dashboard, log explorer, etc.)
    """
    pageType: String

    """
    Associated observe entity of the page. For dashboard, it would be the
    dashboard ID. For log explorer, it would be the dataset ID of the log
    dataset, etc.
    """
    pageEntityId: ObjectId

    """
    For some page, there may be an inner tab structure and this logs which
    tab the user is on.
    """
    pageTab: String

    """
    Extra stuff
    """
    extra: JsonObject
}

"""
Metadata a client can send for a particular stage in a query. Should not change
the behavior of the query, and should only provide some context around what this
stage is used for.
"""
input StageMetadata @goModel(model: "observe/meta/metatypes.StageMetadata") {
    """
    Display name of the stage in the UI
    """
    displayName: String

    """
    Description of the stage
    """
    description: String

    """
    What component feature is this stage driving? i.e. filter bar, visualization etc.
    """
    component: String

    """
    Extra stuff
    """
    extra: JsonObject
}
